<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>00-Java八股文（2）</title>
      <link href="/2024/02/26/java9/"/>
      <url>/2024/02/26/java9/</url>
      
        <content type="html"><![CDATA[<h2 id="Java"><a href="#Java" class="headerlink" title="*Java*"></a>*<em>Java*</em></h2><p>\1. Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？</p><p>\2. String、 StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</p><p>\3. String s1 &#x3D; new String(“abc”);这段代码创建了几个字符串对象？</p><p>\4. &#x3D;&#x3D; 与 equals?hashCode 与 equals ?</p><p>\5. 谈谈对 Java 注解的理解，解决了什么问题？</p><p>\6. Exception 和 Error 有什么区别？</p><p>\7. Java 反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？</p><p>\8. 说说 List,Set,Map 三者的区别？三者底层的数据结构？</p><p>\9. 有哪些集合是线程不安全的？怎么解决呢？</p><p>\10. 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</p><p>\11. HashMap 和 Hashtable 的区别？HashMap 和 HashSet 区别？HashMap 和 TreeMap 区别？</p><p>\12. HashMap 的底层实现</p><p>\13. jvm 内存结构</p><p>\14. 什么是类加载？何时类加载？类加载流程？</p><p>\15. 知道哪些类加载器。类加载器之间的关系？</p><p>\16. Java 内存模型</p><p>\17. GC 的全流程</p><p>\18. 线程和进程的区别。</p><p>\19. 什么是线程死锁?如何避免死锁?</p><p>\20. 乐观锁和悲观锁了解么？</p><p>\21. 说说 sleep() 方法和 wait() 方法区别和共同点?</p><p>\22. error和exception有什么区别?</p><p>\23. 说出5个常见的RuntimeException?</p><p>\24. throw和throws的区别?</p><p>\25. Java中异常处理要怎么处理？</p><p>\26. 什么是 Spring 框架?</p><p>\27. 列举一些重要的 Spring 模块？</p><p>\28. 谈谈自己对于 Spring IoC 和 AOP 的理解</p><p>\29. spring拦截器和过滤器了解么？</p><p>\30. Mybatis优点?</p><p>\31. Mybatis缺点?</p><p>\32. Mybati中的#{}和${}的区别是什么?</p><p>\33. Mybatis中9个动态标签是?</p><p>\34. 什么是 SpringMVC？</p><p>\35. Spring MVC 的优点有哪些？</p><p>\36. 什么是SpringBoot?</p><p>\37. SpringBoot的特征?</p><p>\38. SpringBoot启动类注解?它是由哪些注解组成?</p><p>\39. SpringBoot支持配置文件的格式?</p><p>\40. Tomcat默认端口是多少？</p><p>\41. Tomcat下有哪几个文件夹，有什么用？</p><p><em><strong>*网络*</strong></em> </p><p>\1. OSI 与 TCP&#x2F;IP 各层的结构与功能,都有哪些协议?为什么网络要分层？</p><p>\2. 计算机网络的一些常见状态码</p><p>\3. ping 所使用的协议</p><p>\4. TCP 的三次握手与四次挥手的内容？ TCP 为什么连接是三次握手而断开是四次握手？</p><p>\5. TCP 与 UDP 的区别及使用场景</p><p>\6. HTTP 协议了解么？HTTP 是基于 TCP 还是 UDP 的？</p><p>\7. HTTP 和 HTTPS 的区别了解么？</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="*数据库*"></a><em><strong>*数据库*</strong></em></h3><p><em><strong>*MySQL*</strong></em> </p><p><em><strong>*基础*</strong></em></p><p>\1. 非关系型数据库和关系型数据库的区别？</p><p>\2. 事务的四大特性了解么?</p><p>\3. MySQL 事务隔离级别？默认是什么级别？</p><p>\4. 乐观锁与悲观锁的区别?</p><p>\5. MySQL 数据库两种存储引擎的区别?</p><p><em><strong>*索引*</strong></em></p><p>\1. 为什么索引能提高查询速度?</p><p>\2. 聚集索引和非聚集索引的区别？非聚集索引一定回表查询吗?</p><p>\3. 索引这么多优点，为什么不对表中的每一个列创建一个索引呢？(使用索引一定能提高查询性能吗?)</p><p>\4. 索引底层的数据结构了解么？Hash 索引和 B+树索引优劣分析</p><p>\5. 最左前缀匹配原则了解么？</p><p><em><strong>*进阶*</strong></em></p><p>\1. 一条 SQL 语句在 MySQL 中如何执行的？</p><p>\2. 简单说一下 SQL 调优思路。</p><p>\3. 简单说一下大表优化的思路。</p><p>\4. 分库分表了解么？为什么要分库分表？有哪些常见的分库分表工具(sharding-jdbc、TSharding、MyCAT…)？</p><p><em><strong>*Tomcat*</strong></em> <em><strong>*⭐⭐*</strong></em></p><p>\5. 你怎样给 tomcat 去调优?</p><p>\6. 如何禁用 DNS 查询？</p><p>\7. 怎么调整线程数？如何加大 tomcat 连接数？</p><p>\8. tomcat 中如何禁止列目录下的文件？</p><p>\9. 怎样加大 tomcat 的内存。</p><p><em><strong>*Nginx*</strong></em> <em><strong>*⭐*</strong></em></p><p>· 什么是nginx?</p><p>· nginx主要特征?</p><p>· nginx 常用命令?</p><p>· 工作模式及连接数上限?</p><p>· nginx负载均衡几种算法?</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>00-Java八股文</title>
      <link href="/2024/02/26/java8/"/>
      <url>/2024/02/26/java8/</url>
      
        <content type="html"><![CDATA[<h3 id="一、Java基础篇"><a href="#一、Java基础篇" class="headerlink" title="一、Java基础篇"></a>一、Java基础篇</h3><h3 id="1-接口和抽象类的区别"><a href="#1-接口和抽象类的区别" class="headerlink" title="1.接口和抽象类的区别"></a>1.接口和抽象类的区别</h3><p>（1）抽象类可以有构造方法，而接口没有</p><p>（2）抽象类可以有抽象方法和具体方法，接口只能有抽象方法</p><p>（3）抽象类的成员4种权限修饰符都可以修饰，接口只能用private</p><h3 id="2-重载和重写的区别"><a href="#2-重载和重写的区别" class="headerlink" title="2.重载和重写的区别"></a>2.重载和重写的区别</h3><p>重载发生在同一个类中，方法名相同、参数列表、返回类型、权限修饰符可以不同</p><p>重写发生在子类中，方法名相、参数列表、返回类型都相同，权限修饰符要大于父类方法，声明异常范围要小于父类方法，但是final和private修饰的方法不可重写</p><h3 id="3-x3D-x3D-和equals的区别"><a href="#3-x3D-x3D-和equals的区别" class="headerlink" title="3.&#x3D;&#x3D;和equals的区别"></a>3.&#x3D;&#x3D;和equals的区别</h3><p>&#x3D;&#x3D;比较基本类型，比较的是值，&#x3D;&#x3D;比较引用类型，比较的是内存地址</p><p>equlas是Object类的方法，本质上与&#x3D;&#x3D;一样，但是有些类重写了equals方法，比如String的equals被重写后，比较的是内存地址，另外重写了equlas后，也必须重写hashcode()方法</p><h3 id="4-异常处理机制"><a href="#4-异常处理机制" class="headerlink" title="4.异常处理机制"></a>4.异常处理机制</h3><p>（1）使用try、catch、finaly捕获异常，finaly中的代码一定会执行，捕获异常后程序会继续执行</p><p>（2）使用throws声明该方法可能会抛出的异常类型，出现异常后，程序终止</p><h3 id="5-HashMap原理"><a href="#5-HashMap原理" class="headerlink" title="5.HashMap原理"></a>5.HashMap原理</h3><p>1.HashMap在Jdk1.8以后是基于数组+链表+红黑树来实现的，特点是，key不能重复，可以为null，线程不安全</p><p>2.HashMap的扩容机制：</p><p>HashMap的默认容量为16，默认的负载因子为0.75，当HashMap中元素个数超过容量乘以负载因子的个数时，就创建一个大小为前一次两倍的新数组，再将原来数组中的数据复制到新数组中。当数组长度到达64且链表长度大于8时，链表转为红黑树</p><p>3.HashMap存取原理：</p><p>（1）计算key的hash值，然后进行二次hash，根据二次hash结果找到对应的索引位置</p><p>（2）如果这个位置有值，先进性equals比较，若结果为true则取代该元素，若结果为false，就使用高低位平移法将节点插入链表（JDK8以前使用头插法，但是头插法在并发扩容时可能会造成环形链表或数据丢失，而高低位平移发会发生数据覆盖的情况）</p><h3 id="6-想要线程安全的HashMap怎么办？"><a href="#6-想要线程安全的HashMap怎么办？" class="headerlink" title="6.想要线程安全的HashMap怎么办？"></a>6.想要线程安全的HashMap怎么办？</h3><p>（1）使用ConcurrentHashMap</p><p>（2）使用HashTable</p><p>（3）Collections.synchronizedHashMap()方法</p><h3 id="7-ConcurrentHashMap原如何保证的线程安全？"><a href="#7-ConcurrentHashMap原如何保证的线程安全？" class="headerlink" title="7.ConcurrentHashMap原如何保证的线程安全？"></a>7.ConcurrentHashMap原如何保证的线程安全？</h3><p>JDK1.7:使用分段锁，将一个Map分为了16个段，每个段都是一个小的hashmap，每次操作只对其中一个段加锁</p><p>JDK1.8:采用CAS+Synchronized保证线程安全，每次插入数据时判断在当前数组下标是否是第一次插入，是就通过CAS方式插入，然后判断f.hash是否&#x3D;-1，是的话就说明其他线程正在进行扩容，当前线程也会参与扩容；删除方法用了synchronized修饰，保证并发下移除元素安全</p><h3 id="8-HashTable与HashMap的区别"><a href="#8-HashTable与HashMap的区别" class="headerlink" title="8.HashTable与HashMap的区别"></a>8.HashTable与HashMap的区别</h3><p>（1）HashTable的每个方法都用synchronized修饰，因此是线程安全的，但同时读写效率很低</p><p>（2）HashTable的Key不允许为null</p><p>（3）HashTable只对key进行一次hash，HashMap进行了两次Hash</p><p>（4）HashTable底层使用的数组加链表</p><h3 id="9-ArrayList和LinkedList的区别"><a href="#9-ArrayList和LinkedList的区别" class="headerlink" title="9.ArrayList和LinkedList的区别"></a>9.ArrayList和LinkedList的区别</h3><p>ArratList的底层使用动态数组，默认容量为10，当元素数量到达容量时，生成一个新的数组，大小为前一次的1.5倍，然后将原来的数组copy过来；</p><p>因为数组有索引，所以ArrayList查找数据更快，但是添加数据效率更低</p><p>LinkedList的底层使用链表，在内存中是离散的，没有扩容机制；LinkedList在查找数据时需要从头遍历，所以查找慢，但是添加数据效率更高</p><h3 id="10-如何保证ArrayList的线程安全？"><a href="#10-如何保证ArrayList的线程安全？" class="headerlink" title="10.如何保证ArrayList的线程安全？"></a>10.如何保证ArrayList的线程安全？</h3><p>（1）使用collentions.synchronizedList（）方法为ArrayList加锁</p><p>（2）使用Vector，Vector底层与Arraylist相同，但是每个方法都由synchronized修饰，速度很慢</p><p>（3）使用juc下的CopyOnWriterArrayList，该类实现了读操作不加锁，写操作时为list创建一个副本，期间其它线程读取的都是原本list，写操作都在副本中进行，写入完成后，再将指针指向副本。</p><h3 id="11-String、StringBuffer、StringBuilder的区别"><a href="#11-String、StringBuffer、StringBuilder的区别" class="headerlink" title="11.String、StringBuffer、StringBuilder的区别"></a>11.String、StringBuffer、StringBuilder的区别</h3><p>String 由 char[] 数组构成，使用了 final 修饰，对 String 进行改变时每次都会新生成一个 String 对象，然后把指针指向新的引用对象。</p><p>StringBuffer可变并且线程安全；</p><p>StringBuiler不可变并且线程不安全。</p><p>操作少量字符数据用 String；单线程操作大量数据用 StringBuilder；多线程操作大量数据用 StringBuffer</p><h3 id="12-谈谈对java注解的理解，解决了什么问题？"><a href="#12-谈谈对java注解的理解，解决了什么问题？" class="headerlink" title="12.谈谈对java注解的理解，解决了什么问题？"></a>12.谈谈对java注解的理解，解决了什么问题？</h3><p>注解是Java编程中强大且灵活的工具，它们可以提供额外的元数据，用于代码文档化、配置、代码生成和增强等方面。通过使用注解，可以改善代码的可读性、可维护性和扩展性。</p><p>提供编译时检查和静态分析：注解可以用于对代码进行静态验证和分析。通过在代码中添加注解，可以告诉编译器执行特定的检查，并在编译时捕获潜在的错误。例如，@Override 注解用于标记方法覆盖父类的方法，如果方法签名不正确，则会在编译时产生错误。</p><p>代码文档化和自动生成文档：注解可以用于生成代码的文档。通过添加注解，开发人员可以为代码元素（如类、方法和参数）提供描述性信息。这些注解可以由工具（如Javadoc）读取，并用于生成文档。例如，@Deprecated 注解用于标记已弃用的代码，开发人员在使用过程中会得到相应的警告。</p><p>运行时处理和反射：注解可以在运行时使用反射机制进行处理。通过反射，可以读取和解析注解的信息，并根据注解来执行特定的操作。这为框架和库提供了更大的灵活性，可以在运行时根据注解配置和扩展代码的行为。例如，JUnit 测试框架使用注解来标记测试方法，并在运行时执行这些方法。</p><p>元数据配置和扩展：注解可以用于配置应用程序的元数据。通过添加注解，可以为类、方法和字段添加配置信息，以指定其在特定环境中的行为。这可以减少配置文件的使用，并将配置信息与代码紧密集成。例如，Spring 框架使用注解来配置依赖注入、事务管理和其他应用程序行为。</p><p>代码生成和增强：注解可以用于生成或增强代码。通过添加注解，可以指示代码生成工具在编译时生成额外的代码。这对于减少重复的样板代码、实现设计模式或自动化任务非常有用。例如，Lombok 库使用注解来自动生成 getter、setter 和构造函数等代码。<br>————————————————</p><pre><code>                        版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</code></pre><p>原文链接：<a href="https://blog.csdn.net/qq_46285584/article/details/135897682">https://blog.csdn.net/qq_46285584/article/details/135897682</a></p><h3 id="13-exception和error的区别"><a href="#13-exception和error的区别" class="headerlink" title="13.exception和error的区别"></a>13.exception和error的区别</h3><p>Error通常指的是与虚拟机相关的问题，如系统崩溃、内存空间不足、方法调用错误等，这类错误通常会导致应用程序中断，并且对于这类错误，程序本身无法恢复，建议让程序终止。而Exception则表示程序可以处理的异常，例如运行时异常和受检查的异常，这些异常可以被程序捕获并可能恢复，遇到这类异常时，应该尽可能处理，使程序恢复运行，而不应该随意终止。Exception又分为运行时异常和受检查的异常，受检查的异常需要显式地进行捕获处理，否则编译不会通过。</p><h3 id="14-mybatis中-和-的区别是什么"><a href="#14-mybatis中-和-的区别是什么" class="headerlink" title="14.mybatis中#和$的区别是什么"></a>14.mybatis中#和$的区别是什么</h3><p>1、传入的参数在SQL中显示不同</p><p>#传入的参数在SQL中显示为字符串（当成一个字符串），会对自动传入的数据加一个双引号。</p><p>例：使用以下SQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,age from student where id =#&#123;id&#125;</span><br></pre></td></tr></table></figure><p>当我们传递的参数id为 “1” 时，上述 sql 的解析为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,age from student where id =&quot;1&quot;</span><br></pre></td></tr></table></figure><p>$传入的参数在SqL中直接显示为传入的值</p><p>例：使用以下SQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,age from student where id =$&#123;id&#125;</span><br></pre></td></tr></table></figure><p>当我们传递的参数id为 “1” 时，上述 sql 的解析为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,age from student where id =1</span><br></pre></td></tr></table></figure><p>2、#可以防止SQL注入的风险（语句的拼接）；但$无法防止Sql注入。</p><p>3、$方式一般用于传入数据库对象，例如传入表名。</p><p>4、大多数情况下还是经常使用#，一般能用#的就别用$；但有些情况下必须使用$，例：MyBatis排序时使用order by 动态参数时需要注意，用$而不是#。</p><h3 id="二-Java多线程篇"><a href="#二-Java多线程篇" class="headerlink" title="二.Java多线程篇"></a>二.Java多线程篇</h3><h3 id="1-进程和线程的区别"><a href="#1-进程和线程的区别" class="headerlink" title="1.进程和线程的区别"></a>1.进程和线程的区别</h3><p>进程：系统运行的基本单位，包含多个线程</p><p>线程：独立运行的最小单位，是进程的实体，多个线程共享同一进程内的系统资源</p><h3 id="2-什么是线程上下文切换"><a href="#2-什么是线程上下文切换" class="headerlink" title="2. 什么是线程上下文切换"></a>2. 什么是线程上下文切换</h3><p>当一个线程被剥夺cpu使用权时，切换到另外一个线程执行</p><h3 id="3-什么是死锁"><a href="#3-什么是死锁" class="headerlink" title="3.什么是死锁"></a>3.什么是死锁</h3><p>死锁指多个线程在执行过程中，因争夺资源造成的一种相互等待的僵局</p><h3 id="4-死锁的必要条件"><a href="#4-死锁的必要条件" class="headerlink" title="4.死锁的必要条件"></a>4.死锁的必要条件</h3><p>互斥条件：同一资源同时只能由一个线程读取</p><p>不可抢占条件：不能强行剥夺线程占有的资源</p><p>请求和保持条件：请求其他资源的同时对自己手中的资源保持不放</p><p>循环等待条件：在相互等待资源的过程中，形成一个闭环</p><p>想要预防死锁，只需要破坏其中一个条件即可，银行家算法可以预防死锁</p><h3 id="5-Synchrpnized和lock的区别"><a href="#5-Synchrpnized和lock的区别" class="headerlink" title="5.Synchrpnized和lock的区别"></a>5.Synchrpnized和lock的区别</h3><p>（1）synchronized是关键字，lock是一个类</p><p>（2） synchronized在发生异常时会自动释放锁，lock需要手动释放锁</p><p>（3）synchronized是可重入锁、非公平锁、不可中断锁，lock是可重入锁，可中断锁，可以是公平锁</p><h3 id="6-sleep-和wait-的区别"><a href="#6-sleep-和wait-的区别" class="headerlink" title="6.sleep()和wait()的区别"></a>6.sleep()和wait()的区别</h3><p>(1)wait()是Object的方法，sleep()是Thread类的方法</p><p>(2)wait()会释放锁，sleep()不会释放锁</p><p>(3)wait()要在同步方法或者同步代码块中执行，sleep()没有限制</p><p>(4)wait()要调用notify()或notifyall()唤醒,sleep()自动唤醒</p><h3 id="7-yield-和join-区别"><a href="#7-yield-和join-区别" class="headerlink" title="7.yield()和join()区别"></a>7.yield()和join()区别</h3><p>yield()调用后线程进入就绪状态</p><p>A线程中调用B线程的join() ,则B执行完前A进入阻塞状态</p><h3 id="8-线程池七大参数"><a href="#8-线程池七大参数" class="headerlink" title="8.线程池七大参数"></a>8.线程池七大参数</h3><p>核心线程数：线程池中的基本线程数量</p><p>最大线程数：当阻塞队列满了之后，逐一启动</p><p>最大线程的存活时间：当阻塞队列的任务执行完后，最大线长的回收时间</p><p>最大线程的存活时间单位</p><p>阻塞队列：当核心线程满后，后面来的任务都进入阻塞队列</p><p>线程工厂：用于生产线程</p><p>任务拒绝策略：阻塞队列满后，拒绝任务，有四种策略（1）抛异常（2）丢弃任务不抛异常（3）打回任务（4）尝试与最老的线程竞争</p><h3 id="9-Java内存模型"><a href="#9-Java内存模型" class="headerlink" title="9.Java内存模型"></a>9.Java内存模型</h3><p>JMM（Java内存模型 ）屏蔽了各种硬件和操作系统的内存访问差异，实现让Java程序在各平台下都能达到一致的内存访问效果，它定义了JVM如何将程序中的变量在主存中读取</p><p>具体定义为：所有变量都存在主存中，主存是线程共享区域；每个线程都有自己独有的工作内存，线程想要操作变量必须从主从中copy变量到自己的工作区，每个线程的工作内存是相互隔离的</p><p>由于主存与工作内存之间有读写延迟，且读写不是原子性操作，所以会有线程安全问题</p><h3 id="10-保证并发安全的三大特性？"><a href="#10-保证并发安全的三大特性？" class="headerlink" title="10.保证并发安全的三大特性？"></a>10.保证并发安全的三大特性？</h3><p>原子性：一次或多次操作在执行期间不被其他线程影响</p><p>可见性：当一个线程在工作内存修改了变量，其他线程能立刻知道</p><p>有序性：JVM对指令的优化会让指令执行顺序改变，有序性是禁止指令重排</p><h3 id="11-volatile"><a href="#11-volatile" class="headerlink" title="11.volatile"></a>11.volatile</h3><p>保证变量的可见性和有序性，不保证原子性。使用了 volatile 修饰变量后，在变量修改后会立即同步到主存中，每次用这个变量前会从主存刷新。</p><p>单例模式双重校验锁变量为什么使用 volatile 修饰？ 禁止 JVM 指令重排序，new Object()分为三个步骤：申请内存空间，将内存空间引用赋值给变量，变量初始化。如果不禁止重排序，有可能得到一个未经初始化的变量。</p><h3 id="12-线程使用方式"><a href="#12-线程使用方式" class="headerlink" title="12.线程使用方式"></a>12.线程使用方式</h3><p>(1)继承 Tread 类</p><p>(2)实现 Runnable 接口</p><p>(3)实现 Callable 接口：带有返回值</p><h3 id="13-ThreadLocal原理"><a href="#13-ThreadLocal原理" class="headerlink" title="13.ThreadLocal原理"></a>13.ThreadLocal原理</h3><p>原理是为每个线程创建变量副本，不同线程之间不可见，保证线程安全。每个线程内部都维护了一个Map，key为threadLocal实例，value为要保存的副本。</p><p>但是使用ThreadLocal会存在内存泄露问题，因为key为弱引用，而value为强引用，每次gc时key都会回收，而value不会被回收。所以为了解决内存泄漏问题，可以在每次使用完后删除value或者使用static修饰ThreadLocal，可以随时获取value</p><h3 id="14-什么是CAS锁"><a href="#14-什么是CAS锁" class="headerlink" title="14.什么是CAS锁"></a>14.什么是CAS锁</h3><p>CAS锁可以保证原子性，思想是更新内存时会判断内存值是否被别人修改过，如果没有就直接更新。如果被修改，就重新获取值，直到更新完成为止。这样的缺点是</p><p>（1）只能支持一个变量的原子操作，不能保证整个代码块的原子操作</p><p>（2）CAS频繁失败导致CPU开销大</p><p>（3）ABS问题:线程1和线程2同时去修改一个变量，将值从A改为B，但线程1突然阻塞，此时线程2将A改为B,然后线程3又将B改成A,此时线程1将A又改为B,这个过程线程2是不知道的，这就是ABA问题，可以通过版本号或时间戳解决</p><h3 id="15-Synchronized锁原理和优化"><a href="#15-Synchronized锁原理和优化" class="headerlink" title="15.Synchronized锁原理和优化"></a>15.Synchronized锁原理和优化</h3><p>Synchronize是通过对象头的markwordk来表明监视器的，监视器本质是依赖操作系统的互斥锁实现的。操作系统实现线程切换要从用户态切换为核心态，成本很高，此时这种锁叫重量级锁，在JDK1.6以后引入了偏向锁、轻量级锁、重量级锁</p><p>偏向锁：当一段代码没有别的线程访问，此时线程去访问会直接获取偏向锁</p><p>轻量级锁：当锁是偏向锁时，有另外一个线程来访问，偏向锁会升级为轻量级锁，这个线程会通过自旋方式不断获取锁，不会阻塞，提高性能</p><p>重量级锁：轻量级锁自旋一段时间后线程还没有获取到锁，线程就会进入阻塞状态，该锁会升级为重量级锁，重量级锁时，来竞争锁的所有线程都会阻塞，性能降低</p><p>注意，锁只能升级不能降级</p><h3 id="16-JUC常用辅助类"><a href="#16-JUC常用辅助类" class="headerlink" title="16.JUC常用辅助类"></a>16.JUC常用辅助类</h3><p>CountDownLatch:设定一个数，当调用CountDown()时数量减一，当调用await() 时判断计数器是否为0，不为0就阻塞，直到计数器为0</p><p>CyclicBarrier：设定一个数,当调用await() 时判断计数器是否达到目标值，未达到就阻塞，直到计数器达到目标值</p><p>Semaphore:设定一个信号量，当调用acquire()时判断是否还有信号，有就信号量减一线程继续执行，没有就阻塞等待其他线程释放信号量，当调用release()时释放信号量，唤醒阻塞线程</p><h3 id="17-如何根据-CPU-核心数设计线程池线程数量"><a href="#17-如何根据-CPU-核心数设计线程池线程数量" class="headerlink" title="17.如何根据 CPU 核心数设计线程池线程数量"></a>17.如何根据 CPU 核心数设计线程池线程数量</h3><p>IO 密集型：核心数*2</p><p>计算密集型： 核心数+1</p><p>为什么加 1？即使当计算密集型的线程偶尔由于缺失故障或者其他原因而暂停时，这个额外的线程也能确保 CPU 的时钟周期不会被浪费。</p><h3 id="三-JVM篇"><a href="#三-JVM篇" class="headerlink" title="三.JVM篇"></a>三.JVM篇</h3><h3 id="1-JVM运行时数据区（内存结构）"><a href="#1-JVM运行时数据区（内存结构）" class="headerlink" title="1.JVM运行时数据区（内存结构）"></a>1.JVM运行时数据区（内存结构）</h3><p>线程私有区：</p><p>（1）虚拟机栈：每次调用方法都会在虚拟机栈中产生一个栈帧，每个栈帧中都有方法的参数、局部变量、方法出口等信息，方法执行完毕后释放栈帧</p><p>（2）本地方法栈：为native修饰的本地方法提供的空间，在HotSpot中与虚拟机合二为一</p><p>（3）程序计数器：保存指令执行的地址，方便线程切回后能继续执行代码</p><p>线程共享区：</p><p>（4）堆内存：Jvm进行垃圾回收的主要区域，存放对象信息，分为新生代和老年代</p><p>（5）方法区：存放类信息、静态变量、常量、运行时常量池等信息。JDK1.8之前用持久代实现，JDK1.8后用元空间实现，元空间使用的是本地内存，而非在JVM内存结构中</p><h3 id="2-什么情况下会内存溢出？"><a href="#2-什么情况下会内存溢出？" class="headerlink" title="2.什么情况下会内存溢出？"></a>2.什么情况下会内存溢出？</h3><p>堆内存溢出：（1）当对象一直创建而不被回收时（2）加载的类越来越多时（3)虚拟机栈的线程越来越多时</p><p>栈溢出：方法调用次数过多，一般是递归不当造成</p><h3 id="3-JVM有哪些垃圾回收算法？"><a href="#3-JVM有哪些垃圾回收算法？" class="headerlink" title="3.JVM有哪些垃圾回收算法？"></a>3.JVM有哪些垃圾回收算法？</h3><p>（1）标记清除算法： 标记不需要回收的对象，然后清除没有标记的对象，会造成许多内存碎片。</p><p>（2）复制算法： 将内存分为两块，只使用一块，进行垃圾回收时，先将存活的对象复制到另一块区域，然后清空之前的区域。用在新生代</p><p>（3）标记整理算法： 与标记清除算法类似，但是在标记之后，将存活对象向一端移动，然后清除边界外的垃圾对象。用在老年代</p><h3 id="4-GC如何判断对象可以被回收？"><a href="#4-GC如何判断对象可以被回收？" class="headerlink" title="4.GC如何判断对象可以被回收？"></a>4.GC如何判断对象可以被回收？</h3><p>（1）引用计数法：已淘汰，为每个对象添加引用计数器，引用为0时判定可以回收，会有两个对象相互引用无法回收的问题</p><p>（2）可达性分析法：从GCRoot开始往下搜索，搜索过的路径称为引用链，若一个对象GCRoot没有任何的引用链，则判定可以回收</p><p>GCRoot有：虚拟机栈中引用的对象，方法区中静态变量引用的对象，本地方法栈中引用的对象</p><h3 id="5-典型垃圾回收器"><a href="#5-典型垃圾回收器" class="headerlink" title="5.典型垃圾回收器"></a>5.典型垃圾回收器</h3><p>G1 ：JDK1.9以后的默认垃圾回收器，支持并发，采用标记整理+复制算法，注重响应速度</p><h3 id="6-类加载器和双亲委派机制"><a href="#6-类加载器和双亲委派机制" class="headerlink" title="6.类加载器和双亲委派机制"></a>6.类加载器和双亲委派机制</h3><p>从父类加载器到子类加载器分别为：</p><p>BootStrapClassLoader 加载路径为：JAVA_HOME&#x2F;jre&#x2F;lib</p><p>ExtensionClassLoader 加载路径为：JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</p><p>ApplicationClassLoader 加载路径为：classpath</p><p>还有一个自定义类加载器</p><p>当一个类加载器收到类加载请求时，会先把这个请求交给父类加载器处理，若父类加载器找不到该类，再由自己去寻找。该机制可以避免类被重复加载，还可以避免系统级别的类被篡改</p><h3 id="7-类加载过程"><a href="#7-类加载过程" class="headerlink" title="7.类加载过程"></a>7.类加载过程</h3><p>（1）加载 ：加载字节码文件，将字节码中的静态变量和常量转换到方法区中，在堆中生成class对象作为方法区入口</p><p>（2）连接：</p><p>验证：验证字节码文件的正确性。</p><p>准备：正式为类变量在方法区中分配内存，并设置初始值。</p><p>解析：将符号引用（如类的全限定名）解析为直接引用（类在实际内存中的地址）。（）</p><p>（3）初始化 ：执行类构造器（不是常规的构造方法），为静态变量赋初值并初始化静态代码块。</p><h3 id="8-JVM中有哪些引用？"><a href="#8-JVM中有哪些引用？" class="headerlink" title="8.JVM中有哪些引用？"></a>8.JVM中有哪些引用？</h3><p>强引用：new的对象。哪怕内存溢出也不会回收</p><p>软引用：只有内存不足时才会回收</p><p>弱引用：每次垃圾回收都会回收</p><p>虚引用：必须配合引用队列使用，一般用于追踪垃圾回收动作</p><h3 id="9-对象头中有哪些信息"><a href="#9-对象头中有哪些信息" class="headerlink" title="9.对象头中有哪些信息"></a>9.对象头中有哪些信息</h3><p>对象头中有两部分，一部分是MarkWork,存储对象运行时的数据，如GC分代年龄、GC标记、锁的状态、线程ID等；另外一部分是指向对象类型的指针，如果是数组，还有一个部分存放数组长度</p><h3 id="10-JVM内存参数"><a href="#10-JVM内存参数" class="headerlink" title="10.JVM内存参数"></a>10.JVM内存参数</h3><p>-Xmx[]:堆空间最大内存</p><p>-Xms[]:堆空间最小内存，一般设置成跟堆空间最大内存一样的</p><p>-Xmn[]:新生代的最大内存</p><p>-xx[use 垃圾回收器名称]：指定垃圾回收器</p><p>-xss:设置单个线程栈大小</p><p>一般设堆空间为最大可用物理地址的百分之80</p><h3 id="11-JVM类初始化顺序"><a href="#11-JVM类初始化顺序" class="headerlink" title="11.JVM类初始化顺序"></a>11.JVM类初始化顺序</h3><p>父类静态代码块和静态成员变量-&gt;子类静态代码块和静态成员变量-&gt;父类代码块和普通成员变量-&gt;父类构造方法-&gt;子类代码块和普成员变量-&gt;子类构造方法</p><h3 id="四-Mysql篇"><a href="#四-Mysql篇" class="headerlink" title="四.Mysql篇"></a>四.Mysql篇</h3><h3 id="1-MyIAm和InnoDB的区别"><a href="#1-MyIAm和InnoDB的区别" class="headerlink" title="1.MyIAm和InnoDB的区别"></a>1.MyIAm和InnoDB的区别</h3><p>InnoDB支持事务，MyIAm不支持</p><p>InnoDB支持外键，MyIAm不支持</p><p>InnoDB是聚簇索引，MyIAm是非聚簇索引</p><p>InnoDB支持行锁和表锁，MyIAm只支持表锁</p><p>InnoDB不支持全文索引，MyIAm支持</p><p>InnoDB支持自增和MVCC模式的读写，MyIAm不支持</p><h3 id="2-mysql事务特性"><a href="#2-mysql事务特性" class="headerlink" title="2.mysql事务特性"></a>2.mysql事务特性</h3><p>原子性：一个事务内的操作统一成功或失败</p><p>一致性：事务前后的数据总量不变</p><p>隔离性：事务与事务之间相互不影响</p><p>持久性：事务一旦提交发生的改变不可逆</p><h3 id="3-事务靠什么保证"><a href="#3-事务靠什么保证" class="headerlink" title="3.事务靠什么保证"></a>3.事务靠什么保证</h3><p>原子性：由undolog日志保证，他记录了需要回滚的日志信息，回滚时撤销已执行的sql</p><p>一致性：由其他三大特性共同保证，是事务的目的</p><p>隔离性：由MVCC保证</p><p>持久性：由redolog日志和内存保证，mysql修改数据时内存和redolog会记录操作，宕机时可恢复</p><h3 id="4-事务的隔离级别"><a href="#4-事务的隔离级别" class="headerlink" title="4.事务的隔离级别"></a>4.事务的隔离级别</h3><p>在高并发情况下，并发事务会产生脏读、不可重复读、幻读问题，这时需要用隔离级别来控制</p><p>读未提交： 允许一个事务读取另一个事务已提交的数据，可能出现不可重复读，幻读。</p><p>读提交： 只允许事务读取另一个事务没有提交的数据可能出现不可重复读，幻读。</p><p>可重复读： 确保同一字段多次读取结果一致，可能出现欢幻读。</p><p>可串行化： 所有事务逐次执行，没有并发问日</p><p>Inno DB 默认隔离级别为可重复读级别，分为快照度和当前读，并且通过间隙锁解决了幻读问题。</p><h3 id="5-什么是快照读和当前读"><a href="#5-什么是快照读和当前读" class="headerlink" title="5.什么是快照读和当前读"></a>5.什么是快照读和当前读</h3><p>*快照读读取的是当前数据的可见版本，可能是会过期数据，不加锁的select就是快照都</p><p>*当前读读取的是数据的最新版本，并且当前读返回的记录都会上锁，保证其他事务不会并发修改这条记录。如update、insert、delete、select for undate（排他锁）、select lockin share mode（共享锁） 都是当前读</p><h3 id="6-MVCC是什么"><a href="#6-MVCC是什么" class="headerlink" title="6.MVCC是什么"></a>6.MVCC是什么</h3><p>MVCC是多版本并发控制，为每次事务生成一个新版本数据，每个事务都由自己的版本，从而不加锁就决绝读写冲突，这种读叫做快照读。只在读已提交和可重复读中生效。</p><p>实现原理由四个东西保证，他们是</p><p>undolog日志：记录了数据历史版本</p><p>readView:事务进行快照读时产生的视图，记录了当前系统中活跃的事务id，控制哪个历史版本对当前事务可见</p><p>隐藏字段DB_TRC_ID： 最近修改记录的事务ID</p><p>隐藏字段DB_Roll_PTR： 回滚指针，配合undolog指向数据的上一个版本</p><h3 id="7-MySQL有哪些索引"><a href="#7-MySQL有哪些索引" class="headerlink" title="7.MySQL有哪些索引"></a>7.MySQL有哪些索引</h3><p>主键索引：一张表只能有一个主键索引，主键索引列不能有空值和重复值</p><p>唯一索引：唯一索引不能有相同值，但允许为空</p><p>普通索引：允许出现重复值</p><p>组合索引：对多个字段建立一个联合索引，减少索引开销，遵循最左匹配原则</p><p>全文索引：myisam引擎支持，通过建立倒排索引提升检索效率，广泛用于搜索引擎</p><h3 id="8-聚簇索引和非聚簇索引的区别"><a href="#8-聚簇索引和非聚簇索引的区别" class="headerlink" title="8.聚簇索引和非聚簇索引的区别"></a>8.聚簇索引和非聚簇索引的区别</h3><p>聚簇索引：将索引和值放在了一起，根据索引可以直接获取值，如果主键值很大的话，辅助索引也会变得很大</p><p>非聚簇索引：叶子节点存放的是数据行地址，先根据索引找到数据地址，再根据地址去找数据</p><p>他们都是b+数结构</p><h3 id="9-B和B-数的区别，为什么使用B-数"><a href="#9-B和B-数的区别，为什么使用B-数" class="headerlink" title="9.B和B+数的区别，为什么使用B+数"></a>9.B和B+数的区别，为什么使用B+数</h3><p>二叉树：索引字段有序，极端情况会变成链表形式</p><p>AVL数：树的高度不可控</p><p>B数：控制了树的高度，但是索引值和data都分布在每个具体的节点当中，若要进行范围查询，要进行多次回溯，IO开销大</p><p>B+树：非叶子节点只存储索引值，叶子节点再存储索引+具体数据，从小到大用链表连接在一起，范围查询可直接遍历不需要回溯7</p><h3 id="10-MySQL有哪些锁"><a href="#10-MySQL有哪些锁" class="headerlink" title="10.MySQL有哪些锁"></a>10.MySQL有哪些锁</h3><p>基于粒度：</p><p>*表级锁：对整张表加锁，粒度大并发小</p><p>*行级锁：对行加锁，粒度小并发大</p><p>*间隙锁：间隙锁，锁住表的一个区间，间隙锁之间不会冲突只在可重复读下才生效，解决了幻读</p><p>基于属性：</p><p>*共享锁：又称读锁，一个事务为表加了读锁，其它事务只能加读锁，不能加写锁</p><p>*排他锁：又称写锁，一个事务加写锁之后，其他事务不能再加任何锁，避免脏读问题</p><h3 id="11-MySQL如果做慢查询优化"><a href="#11-MySQL如果做慢查询优化" class="headerlink" title="11.MySQL如果做慢查询优化"></a>11.MySQL如果做慢查询优化</h3><p>（1）分析sql语句，是否加载了不需要的数据列</p><p>（2）分析sql执行计划，字段有没有索引，索引是否失效，是否用对索引</p><p>（3）表中数据是否太大，是不是要分库分表</p><h3 id="12-哪些情况索引会失效"><a href="#12-哪些情况索引会失效" class="headerlink" title="12.哪些情况索引会失效"></a>12.哪些情况索引会失效</h3><p>（1）where条件中有or，除非所有查询条件都有索引，否则失效</p><p>（2）like查询用%开头，索引失效</p><p>（3）索引列参与计算，索引失效</p><p>（4）违背最左匹配原则，索引失效</p><p>（5）索引字段发生类型转换，索引失效</p><p>（6）mysql觉得全表扫描更快时（数据少），索引失效</p><h3 id="13-Mysql内连接、左连接、右连接的区别"><a href="#13-Mysql内连接、左连接、右连接的区别" class="headerlink" title="13.Mysql内连接、左连接、右连接的区别"></a>13.Mysql内连接、左连接、右连接的区别</h3><p>内连接取量表交集部分，左连接取左表全部右表匹部分，右连接取右表全部坐表匹部分</p><h3 id="五-Spring系列-spring全家桶"><a href="#五-Spring系列-spring全家桶" class="headerlink" title="五.Spring系列(spring全家桶)"></a>五.Spring系列(spring全家桶)</h3><h3 id="1-Bean-的作用域"><a href="#1-Bean-的作用域" class="headerlink" title="1.Bean 的作用域"></a>1.Bean 的作用域</h3><p>（1）Singleton:一个IOC容器只有一个</p><p>（2）Prototype:每次调用getBean()都会生成一个新的对象</p><p>（3）request:每个http请求都会创建一个自己的bean</p><p>（4）session:同一个session共享一个实例</p><p>（5）application:整个serverContext只有一个bean</p><p>（6）webSocket:一个websocket只有一个bean</p><h3 id="2-Bean-生命周期"><a href="#2-Bean-生命周期" class="headerlink" title="2.Bean 生命周期"></a>2.Bean 生命周期</h3><p>实例化 Instantiation-&gt;属性赋值 Populate-&gt;初始化 Initialization-&gt;销毁 Destruction</p><p>在这四步的基础上面，Spring 提供了一些拓展点：</p><p>*Bean 自身的方法: 包括了 Bean 本身调用的方法和通过配置文件中的 init-method 和 destroy-method 指定的方法</p><p>*Bean 级生命周期接口方法:包括了 BeanNameAware、BeanFactoryAware、InitializingBean 和 DiposableBean 这些接口的方法</p><p>*容器级生命周期接口方法:包括了 InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。</p><p>*工厂后处理器接口方法: 包括了 AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer 等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</p><h3 id="3-Spring-事务原理？"><a href="#3-Spring-事务原理？" class="headerlink" title="3.Spring 事务原理？"></a>3.Spring 事务原理？</h3><p>spring事务有编程式和声明式，我们一般使用声明式，在某个方法上增加@Transactional注解，这个方法中的sql会统一成功或失败。</p><p>原理是：</p><p>当一个方法加上@Transactional注解，spring会基于这个类生成一个代理对象并将这个代理对象作为bean，当使用这个bean中的方法时，如果存在@Transactional注解，就会将事务自动提交设为false，然后执行方法，执行过程没有异常则提交，有异常则回滚、</p><h3 id="4-spring事务失效场景"><a href="#4-spring事务失效场景" class="headerlink" title="4.spring事务失效场景"></a>4.spring事务失效场景</h3><p>（1）事务方法所在的类没有加载到容器中</p><p>（2）事务方法不是public类型</p><p>（3）同一类中，一个没有添加事务的方法调用另外以一个添加事务的方法，事务不生效</p><p>（4）spring事务默认只回滚运行时异常，可以用rollbackfor属性设置</p><p>（5）业务自己捕获了异常，事务会认为程序正常秩序</p><h3 id="5-spring事务的隔离级别"><a href="#5-spring事务的隔离级别" class="headerlink" title="5.spring事务的隔离级别"></a>5.spring事务的隔离级别</h3><p>default:默认级别，使用数据库自定义的隔离级别</p><p>其它四种隔离级别与mysql一样</p><h3 id="6-spring事务的传播行为"><a href="#6-spring事务的传播行为" class="headerlink" title="6.spring事务的传播行为"></a>6.spring事务的传播行为</h3><p>（1）支持当前事务，如果不存在，则新启一个事务</p><p>（2）支持当前事务，如果不存在，则抛出异常</p><p>（3）支持当前事务，如果不存在，则以非事务方式执行</p><p>（4）不支持当前事务，创建一个新事物</p><p>（5）不支持当前事务，如果已存在事务就抛异常</p><p>（6）不支持当前事务，始终以非事务方式执行</p><h3 id="7-Spring-IoC"><a href="#7-Spring-IoC" class="headerlink" title="7.Spring IoC"></a>7.Spring IoC</h3><h3 id="8-spring用了哪些设计模式"><a href="#8-spring用了哪些设计模式" class="headerlink" title="8.spring用了哪些设计模式"></a>8.spring用了哪些设计模式</h3><p>BeanFactory用了工厂模式，AOP用了动态代理模式，RestTemplate用来模板方法模式，SpringMVC中handlerAdaper用来适配器模式，Spring里的监听器用了观察者模式</p><h3 id="9-SpringMV工作原理"><a href="#9-SpringMV工作原理" class="headerlink" title="9.SpringMV工作原理"></a>9.SpringMV工作原理</h3><p>SpringMVC工作过程围绕着前端控制器DispatchServerlet，几个重要组件有HandleMapping（处理器映射器）、HandleAdapter（处理器适配器）、ViewReslover（试图解析器）</p><p>工作流程：</p><p>（1）DispatchServerlet接收用户请求将请求发送给HandleMapping</p><p>（2）HandleMapping根据请求url找到具体的handle和拦截器，返回给DispatchServerlet</p><p>（3）DispatchServerlet调用HandleAdapter,HandleAdapter执行具体的controller，并将controller返回的ModelAndView返回给DispatchServler</p><p>（4）DispatchServerlet将ModelAndView传给ViewReslover,ViewReslover解析后返回具体view</p><p>（5）DispatchServerlet根据view进行视图渲染，返回给用户</p><h3 id="10-springboot自动配置原理"><a href="#10-springboot自动配置原理" class="headerlink" title="10.springboot自动配置原理"></a>10.springboot自动配置原理</h3><p>启动类@SpringbootApplication注解下，有三个关键注解</p><p>（1）@springbootConfiguration:表示启动类是一个自动配置类</p><p>（2）@CompontScan:扫描启动类所在包外的组件到容器中</p><p>（3）@EnableConfigutarion:最关键的一个注解，他拥有两个子注解，其中@AutoConfigurationpackageu会将启动类所在包下的所有组件到容器中，@Import会导入一个自动配置文件选择器，他会去加载META_INF目录下的spring.factories文件，这个文件中存放很大自动配置类的全类名，这些类会根据元注解的装配条件生效，生效的类就会被实例化，加载到ioc容器中</p><h3 id="11-springboot常用注解"><a href="#11-springboot常用注解" class="headerlink" title="11.springboot常用注解"></a>11.springboot常用注解</h3><p>@RestController ：修饰类，该控制器会返回Json数据</p><p>@RequestMapping(“&#x2F;path”) ：修饰类，该控制器的请求路径</p><p>@Autowired : 修饰属性，按照类型进行依赖注入</p><p>@PathVariable : 修饰参数，将路径值映射到参数上</p><p>@ResponseBody :修饰方法，该方法会返回Json数据</p><p>@RequestBody（需要使用Post提交方式） :修饰参数，将Json数据封装到对应参数中</p><p>@Controller@Service@Compont: 将类注册到ioc容器</p><h3 id="六-Redis系列"><a href="#六-Redis系列" class="headerlink" title="六.Redis系列"></a>六.Redis系列</h3><h3 id="1-redis为什么快？"><a href="#1-redis为什么快？" class="headerlink" title="1.redis为什么快？"></a>1.redis为什么快？</h3><p>（1）完全基于内存操作，数据都存在内存中</p><p>（2）采用单线程，避免了不必要的上下文切换带来的性能问题，也不用考虑锁的问题</p><p>（3）基于非阻塞的io多路复用机制</p><p>（4）数据结构简单，对数据操作简单</p><h3 id="2-redis持久化机制"><a href="#2-redis持久化机制" class="headerlink" title="2.redis持久化机制"></a>2.redis持久化机制</h3><p>（1）快照持久化RDB</p><p>redis的默认持久化机制，通过父进程fork一个子进程，子进程将redis的数据快照写入一个临时文件，等待持久化完毕后替换上一次的rdb文件。整个过程主进程不进行任何的io操作。持久化策略可以通过save配置单位时间内执行多少次操作触发持久化。所以RDB的优点是保证redis性能最大化，恢复速度数据较快，缺点是可能会丢失两次持久化之间的数据</p><p>（2）追加持久化AOF</p><p>以日志形式记录每一次的写入和删除操作，策略有每秒同步、每次操作同步、不同步，优点是数据完整性高，缺点是运行效率低，恢复时间长</p><h3 id="3-Redis如何实现key的过期删除？"><a href="#3-Redis如何实现key的过期删除？" class="headerlink" title="3.Redis如何实现key的过期删除？"></a>3.Redis如何实现key的过期删除？</h3><p>采用的定期过期+惰性过期</p><p>定期删除 ：Redis 每隔一段时间从设置过期时间的 key 集合中，随机抽取一些 key ，检查是否过期，如果已经过期做删除处理。</p><p>惰性删除 ：Redis 在 key 被访问的时候检查 key 是否过期，如果过期则删除。</p><h3 id="4-Redis数据类型"><a href="#4-Redis数据类型" class="headerlink" title="4.Redis数据类型"></a>4.Redis数据类型</h3><p>String 常用命令： set,get,decr,incr,mget等</p><p>Hash 常用命令： hget,hset,hgetall 等</p><p>List 常用命令： lpush,rpush,lpop,rpop,lrange 等</p><p>Set 常用命令： sadd,spop,smembers,sunion 等</p><p>SortSet 常用命令： zadd,zrange,zrem,zcard 等</p><h3 id="5-Redis缓存穿透如何解决？"><a href="#5-Redis缓存穿透如何解决？" class="headerlink" title="5.Redis缓存穿透如何解决？"></a>5.Redis缓存穿透如何解决？</h3><p>缓存穿透是指频繁请求客户端和缓存中都不存在的数据，缓存永远不生效，请求都到达了数据库。</p><p>解决方案：</p><p>（1）在接口上做基础校验，比如id&lt;&#x3D;0就拦截</p><p>（2）缓存空对象：找不到的数据也缓存起来，并设置过期时间，可能会造成短期不一致</p><p>（3）布隆过滤器：在客户端和缓存之间添加一个过滤器，拦截掉一定不存在的数据请求</p><h3 id="6-Redis如何解决缓存击穿？"><a href="#6-Redis如何解决缓存击穿？" class="headerlink" title="6.Redis如何解决缓存击穿？"></a>6.Redis如何解决缓存击穿？</h3><p>缓存击穿是值一个key非常热点，key在某一瞬间失效，导致大量请求到达数据库</p><p>解决方案：</p><p>（1）设置热点数据永不过期</p><p>（2）给缓存重建的业务加上互斥锁，缺点是性能低</p><h3 id="7-Redis如何解决缓存雪崩？"><a href="#7-Redis如何解决缓存雪崩？" class="headerlink" title="7.Redis如何解决缓存雪崩？"></a>7.Redis如何解决缓存雪崩？</h3><p>缓存雪崩是值某一时间Key同时失效或redis宕机，导致大量请求到达数据库</p><p>解决方案：</p><p>（1）搭建集群保证高可用</p><p>（2）进行数据预热，给不同的key设置随机的过期时间</p><p>（3）给缓存业务添加限流降级，通过加锁或队列控制操作redis的线程数量</p><p>（4）给业务添加多级缓存</p><h3 id="8-Redis分布式锁的实现原理"><a href="#8-Redis分布式锁的实现原理" class="headerlink" title="8.Redis分布式锁的实现原理"></a>8.Redis分布式锁的实现原理</h3><p>原理是使用setnx+setex命令来实现，但是会有一系列问题：</p><p>（1）任务时常超过缓存时间，锁自动释放。可以使用Redision看门狗解决</p><p>（2）加锁和释放锁的不是同一线程。可以在Value中存入uuid，删除时进行验证。但是要注意验证锁和删除锁也不是一个原子性操作，可以用lua脚本使之成为原子性操作</p><p>（3）不可重入。可以使用Redision解决（实现机制类似AQS,计数）</p><p>（4）redis集群下主节点宕机导致锁丢失。使用红锁解决</p><h3 id="9-Redis集群方案"><a href="#9-Redis集群方案" class="headerlink" title="9.Redis集群方案"></a>9.Redis集群方案</h3><p>(1)主从模式：个master节点，多个slave节点，master节点宕机slave自动变成主节点</p><p>(2)哨兵模式：在主从集群基础上添加哨兵节点或哨兵集群，用于监控master节点健康状态，通过投票机制选择slave成为主节点</p><p>(3)分片集群：主从模式和哨兵模式解决了并发读的问题，但没有解决并发写的问题，因此有了分片集群。分片集群有多个master节点并且不同master保存不同的数据，master之间通过ping相互监测健康状态。客户端请求任意一个节点都会转发到正确节点，因为每个master都被映射到0-16384个插槽上，集群的key是根据key的hash值与插槽绑定</p><h3 id="10-Redis集群主从同步原理"><a href="#10-Redis集群主从同步原理" class="headerlink" title="10.Redis集群主从同步原理"></a>10.Redis集群主从同步原理</h3><p>主从同步第一次是全量同步：slave第一次请求master节点会根据replid判断是否是第一次同步，是的话master会生成RDB发送给slave。</p><p>后续为增量同步：在发送RDB期间，会产生一个缓存区间记录发送RDB期间产生的新的命令,slave节点在加载完后，会持续读取缓存区间中的数据</p><h3 id="11-Redis缓存一致性解决方案"><a href="#11-Redis缓存一致性解决方案" class="headerlink" title="11.Redis缓存一致性解决方案"></a>11.Redis缓存一致性解决方案</h3><p>更新数据库时把缓存给删除是最优方案，可以更大概率避免并发问题，但是依旧会有缓存删除失败的问题。可以使用分布式事务，或者在删除失败后把key发送到rabbitMQ中进行异步删除重试</p><h3 id="七-计算机网络系列"><a href="#七-计算机网络系列" class="headerlink" title="七.计算机网络系列"></a>七.计算机网络系列</h3><p>添加图片注释，不超过 140 字（可选）</p><h3 id="1-TCP-x2F-IP模型"><a href="#1-TCP-x2F-IP模型" class="headerlink" title="1.TCP&#x2F;IP模型"></a>1.TCP&#x2F;IP模型</h3><h3 id="2-浏览器输入地址后做了什么？"><a href="#2-浏览器输入地址后做了什么？" class="headerlink" title="2.浏览器输入地址后做了什么？"></a>2.浏览器输入地址后做了什么？</h3><p>添加图片注释，不超过 140 字（可选）</p><h3 id="3-TCP三次握手"><a href="#3-TCP三次握手" class="headerlink" title="3.TCP三次握手"></a>3.TCP三次握手</h3><p><img src="https://pics3.baidu.com/feed/f603918fa0ec08fa14d252deef6dfc6754fbda03.png@f_auto?token=8386135ab3454fa672d09c2e36d46acc" alt="img"></p><p>编辑</p><p>添加图片注释，不超过 140 字（可选）</p><h3 id="4-为什么TCP不能两次握手"><a href="#4-为什么TCP不能两次握手" class="headerlink" title="4.为什么TCP不能两次握手"></a>4.为什么TCP不能两次握手</h3><p>假设是两次握手，若客户端发起的连接请求阻塞在网络中，会造成该报文的重传，这时服务收到连接请求后会立刻进入连接状态，当双方传输完数据结束连接后，第一次阻塞的请求突然又到达了服务端，此时服务端又进入连接状态，而客户端不会响应服务端的连接确认报文</p><h3 id="5-TCP四次挥手"><a href="#5-TCP四次挥手" class="headerlink" title="5.TCP四次挥手"></a>5.TCP四次挥手</h3><p><img src="https://pics0.baidu.com/feed/a71ea8d3fd1f4134737a69f9939c54c0d0c85e72.png@f_auto?token=3d1907ffbd806482633376340be137d0" alt="img"></p><p>编辑</p><p>切换为居中</p><p>添加图片注释，不超过 140 字（可选）</p><h3 id="6-为什么要进入时间等待状态？"><a href="#6-为什么要进入时间等待状态？" class="headerlink" title="6.为什么要进入时间等待状态？"></a>6.为什么要进入时间等待状态？</h3><p>若客户端发送确认释放包后直接关闭，而服务端因为某种原因没有收到客户端的确认释放包，就会一直发送确认请求，而客户端永远不会再响应该请求。</p><h3 id="7-TCP-滑动窗口"><a href="#7-TCP-滑动窗口" class="headerlink" title="7.TCP 滑动窗口"></a>7.TCP 滑动窗口</h3><p>TCP 流量控制，主要使用滑动窗口协议，滑动窗口是接受数据端使用的窗口大小，用来告诉发送端接收端的缓存大小，以此可以控制发送端发送数据的大小，从而达到流量控制的目的。如果TCP发送方收到接收方的零窗口通知后，会启动持续计时器。计时器超时后向接收方发送零窗口探测报文，如果响应仍为0，就重新计时，不为0就打破死锁</p><h3 id="8-TCP拥塞控制"><a href="#8-TCP拥塞控制" class="headerlink" title="8.TCP拥塞控制"></a>8.TCP拥塞控制</h3><p>发送方会维护一个拥塞窗口大小的状态变量，大小取决于网络的拥塞程度。发送方的发送窗口大小是取接收方接收窗口和拥塞窗口中较小的一个</p><p>拥塞控制有四种算法：</p><p>慢开始：从小到大主键发送窗口，每收到一个确认报文窗口大小指数增长</p><p>拥塞避免：当窗口大小到达一定阈值时，转为拥塞避免，每收到一个确认报文窗口大小+1。若此时网络超时，就把阈值调小一半，重新慢开始</p><p>快重传：要求接收方收到请求后要立即回复</p><p>快恢复：发送方连续收到多个确认时，就把拥塞避免阈值减小，然后直接开始拥塞避免</p><h3 id="9-TCP超时重传"><a href="#9-TCP超时重传" class="headerlink" title="9.TCP超时重传"></a>9.TCP超时重传</h3><p>发送方在发送按数据后一定时间内没有收到接收方响应报文，就会重新发送刚刚的报文，接收到收到报文后会对该报文的序列号进行检验，已存在就抛弃</p><h3 id="10-TCP可靠传输的实现"><a href="#10-TCP可靠传输的实现" class="headerlink" title="10.TCP可靠传输的实现"></a>10.TCP可靠传输的实现</h3><p>TCP是靠滑动窗口协议和连续ARQ协议配合流量控制和拥塞控制来保证的可靠传输。</p><p>ARQ是停止等待协议和自动重传请求，它规定TCP要为每一次传输的包编号，每发送一个包，要等待对方确认后才能发送下一个分组，若一段时间对方没有确认，就重新发送刚刚的报文。接收方会对数据包排序，把有序数据传给应用层，返回缺失的第一个ACK确认序列号给发送方,接收到收到报文后会对该报文的序列号进行检验，重复就丢弃。</p><p>流量控制是…..拥塞窗口上……（上面已经说了）</p><h3 id="11-TCP报头有哪些信息"><a href="#11-TCP报头有哪些信息" class="headerlink" title="11.TCP报头有哪些信息"></a>11.TCP报头有哪些信息</h3><p><img src="https://pics2.baidu.com/feed/32fa828ba61ea8d301fb7db72e89f144241f5832.png@f_auto?token=e351aade3a0022450f4908ad5b2d92e6" alt="img"></p><p>编辑</p><p>切换为居中</p><p>添加图片注释，不超过 140 字（可选）</p><h3 id="12-状态码"><a href="#12-状态码" class="headerlink" title="12.状态码"></a>12.状态码</h3><p>1xx:请求正在处理</p><p>2xx:请求成功处理</p><p>3xx:请求重定向 301：永久重定向 302：临时重定向 304：使用本地缓存</p><p>4xx:客户端错误 400：请求格式错误 403：没有访问权限 404：请求资源不存在</p><p>5xx:服务端错误</p><h3 id="13-socket通信流程"><a href="#13-socket通信流程" class="headerlink" title="13.socket通信流程"></a>13.socket通信流程</h3><p>（1）服务端创建socket并调用bind()方法绑定ip和端口号</p><p>（2）服务端调用listen()方法建立监听，此时服务的scoket还没有打开</p><p>（3）客户端创建socket并调用connect()方法像服务端请求连接</p><p>（4）服务端socket监听到客户端请求后，被动打开，调用accept()方法接收客户端连接请求，当accept()方法接收到客户端connect()方法返回的响应成功的信息后，连接成功</p><p>（5）客户端向socket写入请求信息，服务端读取信息</p><p>（6）客户端调用close()结束链接，服务端监听到释放连接请求后，也结束链接</p><h3 id="八-linux系列"><a href="#八-linux系列" class="headerlink" title="八.linux系列"></a>八.linux系列</h3><h3 id="1-linux常用命令"><a href="#1-linux常用命令" class="headerlink" title="1.linux常用命令"></a>1.linux常用命令</h3><p>ifconfig:查看网络接口详情</p><p>ping：查看与某主机是否能联通</p><p>ps -ef|grep 进程名称：查看进程号</p><p>lost -i 端口 ：查看端口占用情况</p><p>top:查看系统负载情况，包括系统时间、系统所有进程状态、cpu情况</p><p>free:查看内存占用情况</p><p>kill:正常杀死进程，发出的信号可能会被阻塞</p><p>kill -9:强制杀死进程，发送的是exit命令，不会被阻塞</p><h3 id="2-linux的io模型"><a href="#2-linux的io模型" class="headerlink" title="2.linux的io模型"></a>2.linux的io模型</h3><p>IO是数据的读取和写入，用户进程读取一次IO请求分为两个阶段：等待数据到达内核缓冲区和将内核空间数据拷贝到进程空间，当用户去内核中拷贝数据时，要从用户态转为核心态</p><p>5中io模型:</p><h3 id="1-同步阻塞IO模型"><a href="#1-同步阻塞IO模型" class="headerlink" title="(1)同步阻塞IO模型"></a>(1)同步阻塞IO模型</h3><p>用户进程发起io调用后会被阻塞，等待内核数据准备完毕时就被唤醒，将内核数据复制到用户进程。这两个阶段都是阻塞的</p><h3 id="2-同步非阻塞IO模型"><a href="#2-同步非阻塞IO模型" class="headerlink" title="(2)同步非阻塞IO模型"></a>(2)同步非阻塞IO模型</h3><p>用户进程发起IO调用后，若内核数据还未准备好，进程不会被阻塞,而是给用户进程返回一个error，进程会继续干别的事，每隔一段时间就去看看内核数据是否准备好。不过将内核数据复制到用户进程这个阶段依旧是阻塞的</p><h3 id="3-IO多路复用模型"><a href="#3-IO多路复用模型" class="headerlink" title="(3)IO多路复用模型"></a>(3)IO多路复用模型</h3><p>同步非阻塞IO要不停的查看内核中数据是否准备好，十分消耗cpu。IO多路复用让一个线程去监控一个fd文件，每个用户进程都有一个fd文件描述符，将自己的文件描述符写入这个fd文件，当某个用户进程需要的数据准备好后，这个线程就去通知用户进程。</p><h3 id="4-信号IO模型"><a href="#4-信号IO模型" class="headerlink" title="(4)信号IO模型"></a>(4)信号IO模型</h3><p>当用户进程发起IO调用后，会向内核注册一个信号处理函数，进程不会被阻塞，当内核数据准备就绪时就返回一个信号给用户进程，进程就可以直接在这个信号处理函数中获取内核数据进行拷贝。拷贝这个阶段依旧是阻塞的</p><h3 id="（5）异步非阻塞模型"><a href="#（5）异步非阻塞模型" class="headerlink" title="（5）异步非阻塞模型"></a>（5）异步非阻塞模型</h3><p>前面四种全是同步的。进程在发起IO调用后，无论数据是否到达，都直接返回结果。内核数据准备好时，由内核将数据复制给用户进程。两个阶段都是非阻塞的</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git入门教程</title>
      <link href="/2023/07/20/git/"/>
      <url>/2023/07/20/git/</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><strong>git init</strong>:把这个目录变成git可以管理的仓库,目录下会多了一个.git的目录。</p><p>下面以1.txt这个文件为例</p><p><strong>git add 1.txt +git commit -m ‘注释’</strong>:将1.txt这个文件提交给仓库。</p><p><img src="https://bu.dusays.com/2023/07/20/64b8d3a42cc71.png" alt="1.png"></p><p><strong>git status</strong>：查看是否还有文件未提交</p><p><img src="https://bu.dusays.com/2023/07/20/64b8d43a58fbe.png" alt="2.png"></p><p><strong>git diff 1.txt</strong> :看下1.txt文件到底改了什么内容</p><p><strong>git log</strong>：查看历史记录，git log命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为222.如果嫌上面显示的信息太多的话，我们可以使用命令 <strong>git log –pretty&#x3D;oneline</strong>.</p><p><img src="https://bu.dusays.com/2023/07/20/64b8d4c42b507.png" alt="1689834696888.png"></p><p>现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令，第一种是：git reset –hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset –hard HEAD~100 即可。</p><p><strong>git reset –hard HEAD^</strong> ：</p><p><img src="https://bu.dusays.com/2023/07/20/64b8d5664dcdd.png" alt="1689834860181.png"></p><p>我们看到 增加22222 内容我们没有看到了，但是现在我想回退到最新的版本，如：有22222的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下：</p><p>git reset –hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者22222内容的版本号我并不知道呢？要如何知道增加22222内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog 演示如下：</p><p><img src="https://bu.dusays.com/2023/07/20/64b8d5c057245.png" alt="1689834949300.png"></p><p>通过上面的显示我们可以知道，增加内容3333的版本号是 f68b3a5.我们现在可以命令</p><p>git reset –hard  f68b3a5来恢复了。演示如下：</p><p><img src="https://bu.dusays.com/2023/07/20/64b8d5fe25dd8.png" alt="1689835011707.png"></p><h2 id="理解工作区与暂存区的区别？"><a href="#理解工作区与暂存区的区别？" class="headerlink" title="理解工作区与暂存区的区别？"></a><strong>理解工作区与暂存区的区别？</strong></h2><p>工作区：就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。<br>版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。</p><p>我们前面说过使用Git提交文件到版本库有两步：</p><p>第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。</p><p>第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。</p><h2 id="Git撤销修改和删除文件操作。"><a href="#Git撤销修改和删除文件操作。" class="headerlink" title="Git撤销修改和删除文件操作。"></a><strong>Git撤销修改和删除文件操作。</strong></h2><p>一：撤销修改：<br>比如我现在在readme.txt文件里面增加一行 内容为555555555555，我们先通过命令查看如下：</p><p>在我未提交之前，我发现添加5555555555555内容有误，所以我得马上恢复以前的版本，现在我可以有如下几种方法可以做修改：</p><p>第一：如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。</p><p>第二：我可以按以前的方法直接恢复到上一个版本。使用 git reset –hard HEAD^</p><p>命令 git checkout –readme.txt 意思就是，把1.txt文件在工作区做的修改全部撤销，这里有2种情况，如下：</p><p>1.1.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。<br>2.另外一种是1.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。<br>对于第二种情况，我想我们继续做demo来看下，假如现在我对1.txt添加一行 内容为6666666666666，我git add 增加到暂存区后，接着添加内容7777777，我想通过撤销命令让其回到暂存区后的状态。</p><p><strong>注意：命令git checkout – readme.txt 中的 – 很重要，如果没有 – 的话，那么命令变成创建分支了。</strong></p><h2 id="Github远程仓库"><a href="#Github远程仓库" class="headerlink" title="Github远程仓库"></a><strong>Github远程仓库</strong></h2><p>前置注册以及配置sshkey步骤跳过。</p><p>在github上创建仓库后页面会有提示，按照提示进行即可。</p><p>注意：在进行下述步骤前请先git init+git add+git commit -m。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/beichengouo/gittest.git</span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2023/07/20/64b8d96257278.png" alt="1689835878164.png">、</p><p>使用命令git clone克隆一个本地库。</p><p>git clone <a href="https://github.com/beichengouo/gittest.git">https://github.com/beichengouo/gittest.git</a></p><p>总结创建与合并分支命令如下：</p><p>查看分支：git branch</p><p>创建分支：git branch name</p><p>切换分支：git checkout name</p><p>创建+切换分支：git checkout –b name</p><p>合并某分支到当前分支：git merge name</p><p>删除分支：git branch –d name</p><h2 id="git命令大全："><a href="#git命令大全：" class="headerlink" title="git命令大全："></a>git命令大全：</h2><p><strong>一、新建代码库</strong></p><p># 在当前目录新建一个Git代码库<br>$ git init</p><p># 新建一个目录，将其初始化为Git代码库<br>$ git init [project-name] # 下载一个项目和它的整个代码历史<br>$ git clone [url]</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二、配置</span><br></pre></td></tr></table></figure><p># 显示当前的Git配置<br>$ git config –list</p><p># 编辑Git配置文件<br>$ git config -e [–global] # 设置提交代码时的用户信息<br>$ git config [–global] user.name “[name]”<br>$ git config [–global] user.email “[email address]”</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">三、增加/删除文件</span><br></pre></td></tr></table></figure><p># 添加指定文件到暂存区<br>$ git add [file1] [file2] … # 添加指定目录到暂存区，包括子目录<br>$ git add [dir] # 添加当前目录的所有文件到暂存区<br>$ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交<br>$ git add -p</p><p># 删除工作区文件，并且将这次删除放入暂存区<br>$ git rm [file1] [file2] … # 停止追踪指定文件，但该文件会保留在工作区<br>$ git rm –cached [file] # 改名文件，并且将这个改名放入暂存区<br>$ git mv [file-original] [file-renamed]</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">四、代码提交</span><br></pre></td></tr></table></figure><p># 提交暂存区到仓库区<br>$ git commit -m [message] # 提交暂存区的指定文件到仓库区<br>$ git commit [file1] [file2] … -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区<br>$ git commit -a</p><p># 提交时显示所有diff信息<br>$ git commit -v</p><p># 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息<br>$ git commit –amend -m [message] # 重做上一次commit，并包括指定文件的新变化<br>$ git commit –amend [file1] [file2] …</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">五、分支</span><br></pre></td></tr></table></figure><p># 列出所有本地分支<br>$ git branch</p><p># 列出所有远程分支<br>$ git branch -r</p><p># 列出所有本地分支和远程分支<br>$ git branch -a</p><p># 新建一个分支，但依然停留在当前分支<br>$ git branch [branch-name] # 新建一个分支，并切换到该分支<br>$ git checkout -b [branch] # 新建一个分支，指向指定commit<br>$ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系<br>$ git branch –track [branch] [remote-branch] # 切换到指定分支，并更新工作区<br>$ git checkout [branch-name] # 切换到上一个分支<br>$ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间<br>$ git branch –set-upstream [branch] [remote-branch] # 合并指定分支到当前分支<br>$ git merge [branch] # 选择一个commit，合并进当前分支<br>$ git cherry-pick [commit] # 删除分支<br>$ git branch -d [branch-name] # 删除远程分支<br>$ git push origin –delete [branch-name]<br>$ git branch -dr [remote&#x2F;branch]</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">六、标签</span><br></pre></td></tr></table></figure><p># 列出所有tag<br>$ git tag</p><p># 新建一个tag在当前commit<br>$ git tag [tag] # 新建一个tag在指定commit<br>$ git tag [tag] [commit] # 删除本地tag<br>$ git tag -d [tag] # 删除远程tag<br>$ git push origin :refs&#x2F;tags&#x2F;[tagName] # 查看tag信息<br>$ git show [tag] # 提交指定tag<br>$ git push [remote] [tag] # 提交所有tag<br>$ git push [remote] –tags</p><p># 新建一个分支，指向某个tag<br>$ git checkout -b [branch] [tag]</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">七、查看信息</span><br></pre></td></tr></table></figure><p># 显示有变更的文件<br>$ git status</p><p># 显示当前分支的版本历史<br>$ git log</p><p># 显示commit历史，以及每次commit发生变更的文件<br>$ git log –stat</p><p># 搜索提交历史，根据关键词<br>$ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行<br>$ git log [tag] HEAD –pretty&#x3D;format:%s</p><p># 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件<br>$ git log [tag] HEAD –grep feature</p><p># 显示某个文件的版本历史，包括文件改名<br>$ git log –follow [file]<br>$ git whatchanged [file] # 显示指定文件相关的每一次diff<br>$ git log -p [file] # 显示过去5次提交<br>$ git log -5 –pretty –oneline</p><p># 显示所有提交过的用户，按提交次数排序<br>$ git shortlog -sn</p><p># 显示指定文件是什么人在什么时间修改过<br>$ git blame [file] # 显示暂存区和工作区的差异<br>$ git diff</p><p># 显示暂存区和上一个commit的差异<br>$ git diff –cached [file] # 显示工作区与当前分支最新commit之间的差异<br>$ git diff HEAD</p><p># 显示两次提交之间的差异<br>$ git diff [first-branch]…[second-branch] # 显示今天你写了多少行代码<br>$ git diff –shortstat “@{0 day ago}” # 显示某次提交的元数据和内容变化<br>$ git show [commit] # 显示某次提交发生变化的文件<br>$ git show –name-only [commit] # 显示某次提交时，某个文件的内容<br>$ git show [commit]:[filename] # 显示当前分支的最近几次提交<br>$ git reflog</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">八、远程同步</span><br></pre></td></tr></table></figure><p># 下载远程仓库的所有变动<br>$ git fetch [remote] # 显示所有远程仓库<br>$ git remote -v</p><p># 显示某个远程仓库的信息<br>$ git remote show [remote] # 增加一个新的远程仓库，并命名<br>$ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并<br>$ git pull [remote] [branch] # 上传本地指定分支到远程仓库<br>$ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突<br>$ git push [remote] –force</p><p># 推送所有分支到远程仓库<br>$ git push [remote] –all</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">九、撤销</span><br></pre></td></tr></table></figure><p># 恢复暂存区的指定文件到工作区<br>$ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区<br>$ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区<br>$ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变<br>$ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致<br>$ git reset –hard</p><p># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变<br>$ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致<br>$ git reset –hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变<br>$ git reset –keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支<br>$ git revert [commit] # 暂时将未提交的变化移除，稍后再移入<br>$ git stash<br>$ git stash pop</p><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/30044692">Git使用教程,最详细，最傻瓜，最浅显，真正手把手教 - 知乎 (zhihu.com)</a></p><h2 id="git-add-文件"><a href="#git-add-文件" class="headerlink" title="git add 文件"></a>git add 文件</h2><p>方法一 git add 添加多个文件，文件之间以空格隔开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add file1 file2 file3</span><br></pre></td></tr></table></figure><p>方法二 多次git add</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add file1</span><br><span class="line">git add file2</span><br><span class="line">git add file2</span><br></pre></td></tr></table></figure><p>方法三 添加指定目录下的文件<br>config目录下及子目录下所有文件，home目录下的所有.php文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config/*</span><br><span class="line">git home/*.php</span><br></pre></td></tr></table></figure><p>方法四 git add . 添加所有的文件， 或者 git add –all 添加所有的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git add --all</span><br></pre></td></tr></table></figure><h4 id="git-add-文件夹"><a href="#git-add-文件夹" class="headerlink" title="git add 文件夹"></a>git add 文件夹</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add 文件夹名</span><br></pre></td></tr></table></figure><p>git commit 提交到版本库<br>git add 目的是将修改文件由工作区提交到暂存区，可以多次提交<br>然后commit操作，将文件从暂存区提交到版本库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;add new file&quot;</span><br></pre></td></tr></table></figure><p>————————————————</p><p>原文链接：<a href="https://blog.csdn.net/sphinx1122/article/details/89789929">https://blog.csdn.net/sphinx1122/article/details/89789929</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QQ机器人3.0更新工作（6/15）</title>
      <link href="/2023/06/13/qbot2/"/>
      <url>/2023/06/13/qbot2/</url>
      
        <content type="html"><![CDATA[<p>本篇博客记录一下个人qbot搭建工作以及后续更新。</p><p>机器人QQ：2468138690</p><p>可直接验证添加</p><h2 id="最近更新："><a href="#最近更新：" class="headerlink" title="最近更新："></a>最近更新：</h2><h3 id="2023-x2F-6-x2F-13"><a href="#2023-x2F-6-x2F-13" class="headerlink" title="2023&#x2F;6&#x2F;13"></a>2023&#x2F;6&#x2F;13</h3><p>1.优化了用户体验，非管理员统一使用猫娘人格，且增加了好感度设定，默认好感度为30，经测试正常询问专业问题不会出错。现在更偏向于日常聊天。</p><p>2.优化了指令表，删减了几个人格，优化了指令说明。</p><p>3.目前私聊bot也会有1&#x2F;2的概率在每个回答后面增加随机表情。</p><p><a href="https://bu.dusays.com/2023/06/13/648875e382857.jpg"><img src="https://bu.dusays.com/2023/06/13/648875e382857.jpg" alt="Screenshot_2023-06-13-21-56-52-491_com.tencent.mo.jpg"></a></p><p>4.优化了在群内的频繁随机回复情况。</p><p><a href="https://bu.dusays.com/2023/06/13/6488763a87c09.jpg"><img src="https://bu.dusays.com/2023/06/13/6488763a87c09.jpg" alt="Screenshot_2023-06-13-21-59-01-570_com.tencent.mo.jpg"></a></p><h3 id="2023-x2F-6-x2F-15（重大更新）"><a href="#2023-x2F-6-x2F-15（重大更新）" class="headerlink" title="2023&#x2F;6&#x2F;15（重大更新）"></a>2023&#x2F;6&#x2F;15（重大更新）</h3><p>机器人模型替换为gpt-3.5-turbo-16k-0613。现已支持联网功能，支持实时搜索互联网最新消息。</p><p><a href="https://bu.dusays.com/2023/06/15/648a9a9aec70f.jpg"><img src="https://bu.dusays.com/2023/06/15/648a9a9aec70f.jpg" alt="Screenshot_2023-06-15-12-48-58-436_com.tencent.mo.jpg"></a></p><h2 id="通知："><a href="#通知：" class="headerlink" title="通知："></a>通知：</h2><p>gpt的apikey的免费余额会在7.1到期，到时候在决定注册账号白嫖还是绑卡支付（绑卡需要国外信用卡，国内visa不可用比较麻烦）。</p><p>云主机会在7&#x2F;7到期，由于云主机必须是国外主机，不好找便宜的（这个是新用户注册有优惠，三个月20r），有推荐的可以d我。</p><p>所以七月份大概率机器人会停运一段时间。</p>]]></content>
      
      
      <categories>
          
          <category> Ai人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ai </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07-Java基础知识-异常处理</title>
      <link href="/2023/06/01/java7/"/>
      <url>/2023/06/01/java7/</url>
      
        <content type="html"><![CDATA[<h1 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h1><p>在Java编程中，异常处理是一种用于处理程序运行时出现的错误情况的机制。异常是指在程序执行过程中发生的意外或异常情况，如输入错误、计算错误、网络连接问题等。通过合理的异常处理机制，可以使程序更加健壮和可靠。</p><h2 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h2><p>Java中的异常分为两种类型：Checked异常和Unchecked异常。</p><ul><li><p>Checked异常：这些异常在代码编译时会被检查，必须在方法的声明中进行声明或捕获。例如，IOException和SQLException就属于Checked异常。</p></li><li><p>Unchecked异常：这些异常在代码编译时不会被检查，也不需要在方法声明中进行声明或捕获。例如，NullPointerException和ArrayIndexOutOfBoundsException就属于Unchecked异常。</p></li></ul><h2 id="异常处理的关键字"><a href="#异常处理的关键字" class="headerlink" title="异常处理的关键字"></a>异常处理的关键字</h2><p>Java提供了一些关键字用于处理异常情况。</p><ul><li>try：包裹可能抛出异常的代码块，并且后面必须跟着catch块或finally块。</li><li>catch：用于捕获异常，并指定相应的处理逻辑。</li><li>finally：用于定义无论是否发生异常都需要执行的代码块。通常用于资源的释放操作，如关闭文件或数据库连接。</li><li>throw：用于抛出异常，可以手动触发异常的发生。</li><li>throws：在方法声明中指定可能抛出的异常，表示该方法可能会出现异常，需要调用该方法的代码进行处理。</li></ul><h2 id="异常处理的示例代码"><a href="#异常处理的示例代码" class="headerlink" title="异常处理的示例代码"></a>异常处理的示例代码</h2><p>下面是一个简单的示例代码，演示了如何使用try-catch-finally来处理异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionHandlingExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> divide(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获并处理异常</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Error: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论是否发生异常，都会执行的代码块</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Finally block&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="comment">// 除法运算，可能触发除零异常</span></span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，如果除数为0，则会触发ArithmeticException异常，catch块会捕获该异常并输出错误信息，最后无论是否发生异常，finally块中的代码都会被执行。</p><h2 id="异常处理的最佳实践"><a href="#异常处理的最佳实践" class="headerlink" title="异常处理的最佳实践"></a>异常处理的最佳实践</h2><ul><li><p>使用具体的异常类型进行捕获和处理，避免使用泛化的Exception类型，以便更精确地处理异常情况。</p></li><li><p>捕获异常后，可以选择进行恢复操作、重新抛出异常或记录异常信息等处理方式，具体根据实际需求进行决定。</p></li><li><p>在finally块中进行资源的释放操作，确保资源能够被正确关闭，以避免资源泄漏。</p><ul><li><p>尽量避免在finally块中抛出异常，以免覆盖原始的异常信息。</p></li><li><p>在编写自定义异常类时，应该继承自Exception或其子类，并提供适当的构造方法和异常信息。</p></li><li><p>在处理异常时，可以使用多个catch块来捕获不同类型的异常，并针对每种异常类型进行相应的处理逻辑。</p></li><li><p>使用throws关键字声明可能抛出的异常，以便调用该方法的代码能够进行适当的异常处理。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>异常处理是Java编程中重要的一部分，通过合理的异常处理机制可以提高程序的稳定性和可靠性。在编写代码时，要根据具体的情况选择合适的异常类型进行捕获和处理，并注意资源的释放和异常信息的记录。合理的异常处理能够帮助我们更好地应对各种意外情况，使程序更加健壮和可维护。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06-Java基础知识-字符串</title>
      <link href="/2023/06/01/java6/"/>
      <url>/2023/06/01/java6/</url>
      
        <content type="html"><![CDATA[<h1 id="Java字符串简介"><a href="#Java字符串简介" class="headerlink" title="Java字符串简介"></a>Java字符串简介</h1><p>在Java编程中，字符串是一种常见的数据类型，用于表示文本数据。字符串在Java中是不可变的，这意味着一旦创建了一个字符串对象，就无法改变它的内容。Java提供了丰富的字符串处理功能，使得字符串操作变得简单和高效。</p><h2 id="创建字符串对象"><a href="#创建字符串对象" class="headerlink" title="创建字符串对象"></a>创建字符串对象</h2><p>可以使用两种方式来创建字符串对象：</p><ol><li><p>直接赋值：可以使用双引号（”）将文本括起来，创建一个字符串对象。例如：<code>String str = &quot;Hello, Java!&quot;;</code></p></li><li><p>使用<code>new</code>关键字：可以使用<code>new</code>关键字创建一个字符串对象。例如：<code>String str = new String(&quot;Hello, Java!&quot;);</code></p></li></ol><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><p>Java提供了丰富的字符串操作方法，可以对字符串进行各种操作，包括：</p><ul><li>连接字符串：可以使用<code>+</code>操作符或<code>concat()</code>方法将多个字符串连接起来。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> str1 + <span class="string">&quot; &quot;</span> + str2; <span class="comment">// 结果为 &quot;Hello Java&quot;</span></span><br></pre></td></tr></table></figure><ul><li>获取字符串长度：可以使用<code>length()</code>方法获取字符串的长度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, Java!&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str.length(); <span class="comment">// 结果为 13</span></span><br></pre></td></tr></table></figure><ul><li>提取子串：可以使用<code>substring()</code>方法提取字符串的子串。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, Java!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">subStr</span> <span class="operator">=</span> str.substring(<span class="number">7</span>); <span class="comment">// 结果为 &quot;Java!&quot;</span></span><br></pre></td></tr></table></figure><ul><li>查找子串：可以使用<code>indexOf()</code>方法查找子串在字符串中的位置。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, Java!&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> str.indexOf(<span class="string">&quot;Java&quot;</span>); <span class="comment">// 结果为 7</span></span><br></pre></td></tr></table></figure><ul><li>替换字符串：可以使用<code>replace()</code>方法替换字符串中的指定内容。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, Java!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> str.replace(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;World&quot;</span>); <span class="comment">// 结果为 &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><p>在Java中，可以使用<code>equals()</code>方法或<code>compareTo()</code>方法来比较字符串的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEqual</span> <span class="operator">=</span> str1.equals(str2); <span class="comment">// 结果为 false</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">compareResult</span> <span class="operator">=</span> str1.compareTo(str2); <span class="comment">// 结果为 -32，根据字典顺序比较字符串</span></span><br></pre></td></tr></table></figure><h2 id="字符串的不可变性"><a href="#字符串的不可变性" class="headerlink" title="字符串的不可变性"></a>字符串的不可变性</h2><p>在Java中，字符串是不可变的，这意味着一旦创建了一个字符串对象，就无法改变它的内容。这种特性带来了一些优点，例如字符串的共享和安全性。</p><p>由于字符串是不可变的，对字符串进行修改实际上是创建了一个新的字符串对象。因此，频繁的字符串操作可能会导致性能问题。在需要频繁修改字符串的情况下，可以使用<code>StringBuilder</code>或<code>StringBuffer</code>类来提高性能。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java字符串是一种常见的数据类型，具有丰富的操作方法。它的不可变性使得字符串处理更简单和安全。在日常的</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05-Java基础知识-数组</title>
      <link href="/2023/05/17/java5/"/>
      <url>/2023/05/17/java5/</url>
      
        <content type="html"><![CDATA[<h1 id="Java数组介绍"><a href="#Java数组介绍" class="headerlink" title="Java数组介绍"></a>Java数组介绍</h1><p>数组是Java中最常用的数据结构之一，用于存储相同类型的多个元素。数组在Java中具有以下特点：</p><h2 id="1-声明和初始化数组"><a href="#1-声明和初始化数组" class="headerlink" title="1. 声明和初始化数组"></a>1. 声明和初始化数组</h2><p>在Java中，声明数组需要指定数组类型和数组名称，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers; <span class="comment">//声明一个int类型的数组</span></span><br><span class="line">String[] names; <span class="comment">//声明一个String类型的数组</span></span><br></pre></td></tr></table></figure><p>数组的初始化可以通过两种方式进行：</p><h3 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h3><p>静态初始化指在声明数组的同时为数组元素赋初值，使用花括号 <code>&#123;&#125;</code> 来指定初始值，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">//初始化一个包含5个元素的int数组</span></span><br><span class="line">String[] names = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>&#125;; <span class="comment">//初始化一个包含3个元素的String数组</span></span><br></pre></td></tr></table></figure><h3 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h3><p>动态初始化指先声明数组，然后通过 <code>new</code> 关键字为数组分配内存空间，再为数组元素赋值，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; <span class="comment">//声明一个包含5个元素的int数组</span></span><br><span class="line">numbers[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">numbers[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">numbers[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">numbers[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line">numbers[<span class="number">4</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h2 id="2-访问数组元素"><a href="#2-访问数组元素" class="headerlink" title="2. 访问数组元素"></a>2. 访问数组元素</h2><p>数组元素可以通过索引来访问，索引从0开始，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">firstNumber</span> <span class="operator">=</span> numbers[<span class="number">0</span>]; <span class="comment">//访问第一个元素</span></span><br><span class="line"><span class="type">String</span> <span class="variable">firstName</span> <span class="operator">=</span> names[<span class="number">0</span>]; <span class="comment">//访问第一个元素</span></span><br></pre></td></tr></table></figure><h2 id="3-数组长度"><a href="#3-数组长度" class="headerlink" title="3. 数组长度"></a>3. 数组长度</h2><p>可以使用 <code>length</code> 属性获取数组的长度，表示数组中元素的个数，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> numbers.length; <span class="comment">//获取数组的长度</span></span><br></pre></td></tr></table></figure><h2 id="4-遍历数组"><a href="#4-遍历数组" class="headerlink" title="4. 遍历数组"></a>4. 遍历数组</h2><p>遍历数组可以使用循环结构，如 <code>for</code> 循环，来访问数组的每个元素，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">    System.out.println(numbers[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-多维数组"><a href="#5-多维数组" class="headerlink" title="5. 多维数组"></a>5. 多维数组</h2><p>Java还支持多维数组，可以用来存储多个元素的表格或矩阵。多维数组可以通过在声明时指定多个维度来创建，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">3</span>]; <span class="comment">//声明一个3x3的二维数组</span></span><br></pre></td></tr></table></figure><p>以上是对Java数组的简单介绍，数组在Java中具有重要的作用，可以方便地存储和操作大量相同类型的数据。通过掌握数组的使用方法，可以更好地处理和管理数据。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-Java基础知识-运算符</title>
      <link href="/2023/05/17/java4/"/>
      <url>/2023/05/17/java4/</url>
      
        <content type="html"><![CDATA[<h1 id="Java运算符简介"><a href="#Java运算符简介" class="headerlink" title="Java运算符简介"></a>Java运算符简介</h1><p>在Java编程语言中，运算符用于执行各种操作，包括算术、赋值、比较和逻辑等。了解和正确使用这些运算符是编写高效和功能强大的Java程序的基础。</p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>算术运算符用于执行基本的数学运算，例如加法、减法、乘法和除法。以下是常用的算术运算符：</p><ul><li>加法运算符（+）：用于将两个值相加。</li><li>减法运算符（-）：用于将一个值减去另一个值。</li><li>乘法运算符（*）：用于将两个值相乘。</li><li>除法运算符（&#x2F;）：用于将一个值除以另一个值。</li><li>取余运算符（%）：用于计算两个值相除的余数。</li></ul><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符用于将一个值赋给一个变量。常见的赋值运算符是等号（&#x3D;），它将右边的值赋给左边的变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 将值10赋给变量x</span></span><br></pre></td></tr></table></figure><p>除了等号之外，还有一些复合赋值运算符，例如加等（+&#x3D;）、减等（-&#x3D;）、乘等（*&#x3D;）和除等（&#x2F;&#x3D;）。这些复合赋值运算符将右边的值与左边的变量进行运算，并将结果赋给左边的变量。</p><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>比较运算符用于比较两个值之间的关系，并返回一个布尔值（true或false）。以下是常用的比较运算符：</p><ul><li>相等运算符（&#x3D;&#x3D;）：用于检查两个值是否相等。</li><li>不等运算符（!&#x3D;）：用于检查两个值是否不相等。</li><li>大于运算符（&gt;）：用于检查左边的值是否大于右边的值。</li><li>小于运算符（&lt;）：用于检查左边的值是否小于右边的值。</li><li>大于等于运算符（&gt;&#x3D;）：用于检查左边的值是否大于或等于右边的值。</li><li>小于等于运算符（&lt;&#x3D;）：用于检查左边的值是否小于或等于右边的值。</li></ul><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>逻辑运算符用于执行逻辑运算，例如逻辑与（&amp;&amp;）、逻辑或（||）和逻辑非（!）。这些运算符通常用于条件语句和循环结构中。</p><ul><li>逻辑与（&amp;&amp;）：当两个条件都为真时，返回真。</li><li>逻辑或（||）：当至少有一个条件为真时，返回真。</li><li>逻辑非（!）：对条件的结果进行取反。</li></ul><h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><p>除了上述提到的运算符外，还有一些其他常见的运算符，包括：</p><ul><li>自增运算符（++）：用于将变量的值增加1。</li><li>自减运算符（–）：用于将变量的值减少1。</li><li>条件运算符（三元运算符）（? :）：用于根据条件选择不同的值。</li><li>位运算符：用于对数据的位进行操作，例如按位与（&amp;）、按位或（|）、按位异或（^）等。</li><li>移位运算符：用于对数据的位进行移动操作，例如左移（&lt;&lt;）、右移（&gt;&gt;）等。</li><li>instanceof运算符：用于检查对象是否是指定类型的实例。</li><li>强制类型转换运算符：用于将一个数据类型转换为另一个数据类型。</li></ul><p>了解和掌握这些运算符的使用方法和规则，能够帮助我们进行复杂的计算和逻辑操作，提高程序的灵活性和效率。</p><p>以上是Java中一些常见的运算符的简要介绍，通过灵活运用这些运算符，我们可以编写出功能丰富且高效的Java程序。在实际编程中，根据具体需求和场景选择合适的运算符是非常重要的。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-Java基础知识-数据类型</title>
      <link href="/2023/05/12/java3/"/>
      <url>/2023/05/12/java3/</url>
      
        <content type="html"><![CDATA[<h1 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h1><p>Java是一门强类型语言，变量必须先声明并指定数据类型，然后才能进行使用。Java提供了八种基本数据类型和引用类型，本文将简单介绍Java的数据类型。</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Java的八种基本数据类型分为四类，分别是整型、浮点型、字符型和布尔型。</p><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>整型包括四种类型，分别是<code>byte</code>、<code>short</code>、<code>int</code>和<code>long</code>。它们分别占用1、2、4和8个字节，表示的范围也不同，如下表所示：</p><table><thead><tr><th>数据类型</th><th>占用字节数</th><th>表示范围</th></tr></thead><tbody><tr><td>byte</td><td>1</td><td>-128 ~ 127</td></tr><tr><td>short</td><td>2</td><td>-32768 ~ 32767</td></tr><tr><td>int</td><td>4</td><td>-2147483648 ~ 2147483647</td></tr><tr><td>long</td><td>8</td><td>-9223372036854775808 ~ 9223372036854775807</td></tr></tbody></table><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>浮点型包括两种类型，分别是<code>float</code>和<code>double</code>。它们分别占用4和8个字节，表示的范围也不同，如下表所示：</p><table><thead><tr><th>数据类型</th><th>占用字节数</th><th>表示范围</th></tr></thead><tbody><tr><td>float</td><td>4</td><td>1.4E-45 ~ 3.4028235E+38</td></tr><tr><td>double</td><td>8</td><td>4.9E-324 ~ 1.797693134E+308</td></tr></tbody></table><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p>字符型只有一种类型，即<code>char</code>。它占用2个字节，可以表示所有Unicode字符，表示范围为0 ~ 65535。</p><h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><p>布尔型只有一种类型，即<code>boolean</code>。它只有两个取值，分别为<code>true</code>和<code>false</code>，占用1个字节。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>Java的引用类型指除了基本数据类型之外的类型，包括类、接口、数组等。引用类型变量存储的是对象的地址，而不是对象本身。引用类型变量的默认值为<code>null</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简单介绍了Java的八种基本数据类型和引用类型。在实际开发中，我们需要根据需求选择适当的数据类型，以免浪费内存或出现数据精度等问题。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-Java基础知识-简介</title>
      <link href="/2023/05/12/java1/"/>
      <url>/2023/05/12/java1/</url>
      
        <content type="html"><![CDATA[<h1 id="Java简介"><a href="#Java简介" class="headerlink" title="Java简介"></a>Java简介</h1><p>Java是一种面向对象的编程语言，由Sun Microsystems在1995年推出。Java的特点是跨平台、简单易学、安全可靠、支持多线程、面向对象等，这些特点使得Java成为了全球最受欢迎的编程语言之一。</p><h2 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h2><p>Java的跨平台性是由其虚拟机（JVM）实现的。Java程序在编译之后会生成一种特殊的字节码格式，这种字节码可以在任何能够运行Java虚拟机的平台上执行。这意味着，一次编译可以在不同的操作系统和计算机上运行，避免了因为操作系统或硬件的差异而导致的不兼容性问题。</p><h2 id="简单易学"><a href="#简单易学" class="headerlink" title="简单易学"></a>简单易学</h2><p>Java的语法与C++和C语言比较相似，但是相对来说更加简单。Java取消了一些C++中比较复杂的特性，如指针、多继承等。同时，Java还提供了很多高级特性，如自动内存管理、垃圾回收、异常处理等，这些特性都大大减轻了开发人员的工作量，降低了出错的概率。</p><h2 id="安全可靠"><a href="#安全可靠" class="headerlink" title="安全可靠"></a>安全可靠</h2><p>Java提供了很多安全机制，如安全沙箱、类加载器等，这些机制都可以保证Java程序的安全性。Java也提供了一些强制类型检查、空指针检查等功能，这些功能也有助于减少程序中的错误。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>Java提供了丰富的多线程机制，允许开发人员使用多线程来充分利用多核CPU，提高程序的执行效率。Java的多线程机制包括线程类、线程同步、线程池等。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>Java是一种面向对象的编程语言，所有的Java程序都是由对象组成的。Java的面向对象机制包括类、对象、封装、继承、多态等。面向对象的编程思想能够提高程序的可维护性、可扩展性、可重用性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java作为一种跨平台、简单易学、安全可靠、支持多线程、面向对象等的编程语言，应用广泛。Java在各种领域中都有广泛的应用，如Web开发、移动应用开发、桌面应用开发、大数据处理等。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-Java基础知识-变量</title>
      <link href="/2023/05/12/java2/"/>
      <url>/2023/05/12/java2/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的变量"><a href="#Java中的变量" class="headerlink" title="Java中的变量"></a>Java中的变量</h1><p>在Java编程中，变量是存储数据的最基本的单元。变量可以保存各种类型的数据，如整数、浮点数、字符、字符串等等。本文将介绍Java中的变量类型、命名规则和作用域等方面的内容。</p><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>Java中的变量可以分为以下几种类型：</p><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>Java中的基本类型有8种，分别为：</p><ul><li>byte：1字节，范围为-128 ~ 127。</li><li>short：2字节，范围为-32768 ~ 32767。</li><li>int：4字节，范围为-2147483648 ~ 2147483647。</li><li>long：8字节，范围为-9223372036854775808 ~ 9223372036854775807。</li><li>float：4字节，范围为1.4E-45 ~ 3.4028235E38。</li><li>double：8字节，范围为4.9E-324 ~ 1.7976931348623157E308。</li><li>char：2字节，范围为0 ~ 65535。</li><li>boolean：1位，只有两个值：true和false。</li></ul><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>Java中的引用类型指的是对象，这些对象在堆中分配，变量在栈中存储一个引用指向堆中的对象。Java中的引用类型有类、接口、数组、枚举等等。</p><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p>Java中的变量名必须满足以下规则：</p><ul><li>变量名必须以字母、下划线（_）或美元符号（$）开始。</li><li>变量名不能以数字开头。</li><li>变量名只能包含字母、数字、下划线或美元符号。</li><li>变量名区分大小写。</li><li>变量名不能是Java关键字和保留字。</li></ul><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>Java中的变量有不同的作用域。变量的作用域指的是变量在程序中可见的范围。在Java中，变量的作用域可以分为以下几种：</p><h3 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h3><p>类变量是定义在类中的静态变量。这些变量被所有该类的对象共享。在类的定义中使用static关键字定义。</p><h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><p>实例变量是定义在类中，但在方法、语句块或构造函数之外的变量。每个对象都有一份实例变量的副本。</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量是定义在方法、语句块或构造函数中的变量。这些变量只在方法、语句块或构造函数中有效。</p><h2 id="变量的声明和初始化"><a href="#变量的声明和初始化" class="headerlink" title="变量的声明和初始化"></a>变量的声明和初始化</h2><p>Java中的变量需要先声明后使用。声明变量时需要指定变量的类型，变量名以及作用域。变量的初始化指的是为变量赋初值。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog更新工作进展(2023/5/10)</title>
      <link href="/2023/05/10/blog4/"/>
      <url>/2023/05/10/blog4/</url>
      
        <content type="html"><![CDATA[<p>本篇博客记录一下本站搭建工作以及后续更新。</p><h2 id="更新记录："><a href="#更新记录：" class="headerlink" title="更新记录："></a>更新记录：</h2><h3 id="2023-x2F-5-x2F-10："><a href="#2023-x2F-5-x2F-10：" class="headerlink" title="2023&#x2F;5&#x2F;10："></a>2023&#x2F;5&#x2F;10：</h3><p>1.增加了分类和tag（标签）页面。</p><p>2.更改了首页图片，换了张小的，加载更快一点。</p><p>3.增加了友情链接页面。</p><p>4.增加了图片gallery。</p><h2 id="目前bug（2023-x2F-5-x2F-9）："><a href="#目前bug（2023-x2F-5-x2F-9）：" class="headerlink" title="目前bug（2023&#x2F;5&#x2F;9）："></a>目前bug（2023&#x2F;5&#x2F;9）：</h2><p>暂无。</p><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><p>有时候进不了网站可能正在修bug，过段时间清理一下缓存就可以进来了，如果还进不去大概率是我还正在修bug。</p>]]></content>
      
      
      <categories>
          
          <category> blog更新日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog更新工作进展(2023/5/9)</title>
      <link href="/2023/05/09/blog3/"/>
      <url>/2023/05/09/blog3/</url>
      
        <content type="html"><![CDATA[<p>本篇博客记录一下本站搭建工作以及后续更新。</p><h2 id="更新记录："><a href="#更新记录：" class="headerlink" title="更新记录："></a>更新记录：</h2><h3 id="2023-x2F-5-x2F-9："><a href="#2023-x2F-5-x2F-9：" class="headerlink" title="2023&#x2F;5&#x2F;9："></a>2023&#x2F;5&#x2F;9：</h3><p>1.新增了留言板功能。</p><p><img src="/img/1/07.png" alt="07"></p><p>2.添加了Waline评论系统。（不是）</p><p>（在尝试修复国内无法看到评论的bug后，我成功的把原来的waline整个东西搞没了，后续又折腾了好久没折腾回来）</p><p>然后我改用twikoo了，已正常使用。评论被回复后会有邮件提醒（推荐使用qq邮箱，可以获取qq头像）</p><h2 id="目前bug（2023-x2F-5-x2F-9）："><a href="#目前bug（2023-x2F-5-x2F-9）：" class="headerlink" title="目前bug（2023&#x2F;5&#x2F;9）："></a>目前bug（2023&#x2F;5&#x2F;9）：</h2><p>暂无。</p><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><p>有时候进不了网站可能正在修bug，过段时间清理一下缓存就可以进来了，如果还进不去大概率是我还正在修bug。</p>]]></content>
      
      
      <categories>
          
          <category> blog更新日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ai绘画 《无人之城与少女》</title>
      <link href="/2023/05/08/aihuihua/"/>
      <url>/2023/05/08/aihuihua/</url>
      
        <content type="html"><![CDATA[<h2 id="《无人之城与少女》"><a href="#《无人之城与少女》" class="headerlink" title="《无人之城与少女》"></a>《无人之城与少女》</h2><div align=center class="aspect-ratio"><iframe src="//player.bilibili.com/player.html?aid=226741779&bvid=BV1th411V7S9&cid=1072864481&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div>]]></content>
      
      
      <categories>
          
          <category> Ai人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ai </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog更新工作进展(2023/5/8)</title>
      <link href="/2023/05/08/blog2/"/>
      <url>/2023/05/08/blog2/</url>
      
        <content type="html"><![CDATA[<p>本篇博客记录一下本站搭建工作以及后续更新。</p><h2 id="更新记录："><a href="#更新记录：" class="headerlink" title="更新记录："></a>更新记录：</h2><h3 id="2023-x2F-5-x2F-8："><a href="#2023-x2F-5-x2F-8：" class="headerlink" title="2023&#x2F;5&#x2F;8："></a>2023&#x2F;5&#x2F;8：</h3><p>1.搜索功能已修复，可以正常使用</p><p><img src="/img/1/04.png" alt="04"></p><p>2.增加了全程吸底的音乐播放器</p><p><img src="/img/1/05.png" alt="05"></p><p>3.适配了b站视频。</p><p>4.增加alice挂件(pc端才有)，alice女儿可爱捏。</p><p><img src="/img/1/06.png" alt="06"></p><h2 id="目前bug（2023-x2F-5-x2F-8）："><a href="#目前bug（2023-x2F-5-x2F-8）：" class="headerlink" title="目前bug（2023&#x2F;5&#x2F;8）："></a>目前bug（2023&#x2F;5&#x2F;8）：</h2><p>加载动画仍有问题，不打算用加载动画了。</p><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><p>有时候进不了网站可能正在修bug，过段时间清理一下缓存就可以进来了，如果还进不去大概率是我还正在修bug。</p>]]></content>
      
      
      <categories>
          
          <category> blog更新日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog更新工作进展(2023/5/7)</title>
      <link href="/2023/05/07/blog/"/>
      <url>/2023/05/07/blog/</url>
      
        <content type="html"><![CDATA[<p>本篇博客记录一下本站搭建工作以及后续更新。</p><h2 id="更新记录："><a href="#更新记录：" class="headerlink" title="更新记录："></a>更新记录：</h2><h3 id="2023-x2F-5-x2F-7："><a href="#2023-x2F-5-x2F-7：" class="headerlink" title="2023&#x2F;5&#x2F;7："></a>2023&#x2F;5&#x2F;7：</h3><p>1.绑定个人域名beichengouo.top。</p><p>2.pc端网站背景增加动态彩带特效。</p><p>3.新增搜索功能：</p><p><img src="/img/1/04.png" alt="04"></p><p>4.调整了网页整体布局。</p><p>5.更新了相册。</p><p>6.增加了文章封面和tags，调整了文章顺序，增加了置顶文章。</p><h2 id="目前bug（2023-x2F-5-x2F-7）："><a href="#目前bug（2023-x2F-5-x2F-7）：" class="headerlink" title="目前bug（2023&#x2F;5&#x2F;7）："></a>目前bug（2023&#x2F;5&#x2F;7）：</h2><p>本地端搜索栏显示正常，部署到服务器上会显示在最底下，折腾了一下午暂时无法解决。大概率是github作为服务器加载外部网站上的js和css加载太慢了的问题。应该部署到自己服务器上不会出错。目前暂时把搜索和加载动画功能关闭了。</p><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><p>有时候进不了网站可能正在修bug，过段时间清理一下缓存就可以进来了，如果还进不去大概率是我还正在修bug。</p>]]></content>
      
      
      <categories>
          
          <category> blog更新日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QQ机器人2.0更新工作（5/5）</title>
      <link href="/2023/05/05/qbot/"/>
      <url>/2023/05/05/qbot/</url>
      
        <content type="html"><![CDATA[<p>本篇博客记录一下个人qbot搭建工作以及后续更新。qbot搭建具体步骤参考b站呆呆木的教程。在原版基础上做了很多更新，加了很多内容，机器人qq：2468138690（自动加好友），已部署在海外服务器上，秒回复，标注❤️的则为原版没有的内容。</p><h2 id="当前机器人功能游览"><a href="#当前机器人功能游览" class="headerlink" title="当前机器人功能游览"></a>当前机器人功能游览</h2><h3 id="管理员指令表："><a href="#管理员指令表：" class="headerlink" title="管理员指令表："></a>管理员指令表：</h3><p><img src="/img/1/01.png" alt="01"></p><h3 id="用户（非管理）指令："><a href="#用户（非管理）指令：" class="headerlink" title="用户（非管理）指令："></a>用户（非管理）指令：</h3><p><img src="/img/1/02.png" alt="02"></p><h3 id="指令功能介绍："><a href="#指令功能介绍：" class="headerlink" title="指令功能介绍："></a>指令功能介绍：</h3><p>重置会话：重置当前会话。</p><p>指令说明：回复指令说明大全，目前因账号被风控无法在qq群内回复指令大全，私聊正常。</p><p>设置人格：设置gpt初始人格。格式如 设置人格 xxxxxx（描述）</p><p>语音开启&#x2F;关闭：开启&#x2F;关闭语音回复。</p><p>拉黑&#x2F;解除：拉黑指定qq号直至解除或者服务器重启，拉黑后机器人将不会对指定qq进行回复。❤️</p><p>私人模式：开启后非管理无法与机器人对话。❤️</p><p>变xxx：切换对应预置人格。❤️</p><p>醒醒&#x2F;昏睡：醒醒后机器人会在群内随机回复群友的话，初始概率为1&#x2F;3，通过高冷一点&#x2F;呆萌一点命令可以调整回复概率，昏睡开启后机器人将不会随机回复。❤️</p><p>设备信息：显示服务器各参数详细信息。❤️</p><p>磁盘信息：显示服务器磁盘内存信息。❤️</p><p>拉黑检测：检测到指定敏感关键词将自动拉黑对方。❤️</p><p>初始自动检测：第一次对话将自动识别非管理和管理用户。用于加载不同初始设置（比如加载不同人格）。❤️</p><h2 id="最近更新："><a href="#最近更新：" class="headerlink" title="最近更新："></a>最近更新：</h2><h3 id="2023-x2F-5-x2F-1"><a href="#2023-x2F-5-x2F-1" class="headerlink" title="2023&#x2F;5&#x2F;1"></a>2023&#x2F;5&#x2F;1</h3><p>1.机器人新增了发表情的功能，每一次回复有1&#x2F;3概率在后面增加表情。❤️</p><p><img src="/img/1/03.png" alt="03"></p><p>2.修复了切换人格后第一句对话不理人的情况。</p><p>3.优化了回复概率问题。</p><p>4.优化了预置人格，在每句话前增加了时间（每句话都告诉gpt当前时间）。</p>]]></content>
      
      
      <categories>
          
          <category> Ai人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ai </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/05/05/hello-world/"/>
      <url>/2023/05/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>本博客使用 <a href="https://hexo.io/">Hexo</a>制作! 这是我的第一篇文章. 查看 <a href="https://hexo.io/docs/">文档</a> 获得更多信息. 如果你在使用Hexo中遇到任何问题，你可以在 <a href="https://hexo.io/docs/troubleshooting.html">故障排除</a> 中找到答案， 或者你可以在 <a href="https://github.com/hexojs/hexo/issues">GitHub</a>上问我.</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="命令：Create-a-new-post"><a href="#命令：Create-a-new-post" class="headerlink" title="命令：Create a new post"></a>命令：Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="命令：Run-server"><a href="#命令：Run-server" class="headerlink" title="命令：Run server"></a>命令：Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="命令：Generate-static-files"><a href="#命令：Generate-static-files" class="headerlink" title="命令：Generate static files"></a>命令：Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="命令：Deploy-to-remote-sites"><a href="#命令：Deploy-to-remote-sites" class="headerlink" title="命令：Deploy to remote sites"></a>命令：Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> blog更新日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
